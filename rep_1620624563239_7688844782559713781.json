{"@class":"org.knime.js.core.JSONWebNodePage","webNodePageConfiguration":{"@class":"org.knime.js.core.JSONWebNodePageConfiguration","layout":{"rows":[{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":200,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewTaggedElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:24","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":12,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[],"widthXS":1,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":null,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewLowestElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:39","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":10,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[],"widthXS":1,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":200,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewTaggedElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:35","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":12,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":null,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewLowestElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:36","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":12,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":200,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewTaggedElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:46","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":12,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[],"widthXS":2,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":null,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewLowestElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:47","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":8,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[],"widthXS":2,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[],"widthXS":2,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[{"type":"JSONLayoutViewContent","minWidth":null,"minHeight":null,"maxHeight":null,"maxWidth":null,"scrolling":false,"autoResize":true,"resizeMethod":"viewLowestElement","sizeHeight":true,"sizeWidth":false,"nodeID":"58:0:48","resizeTolerance":5,"resizeInterval":null,"additionalStyles":[],"additionalClasses":[]}],"widthXS":8,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]},{"content":[],"widthXS":2,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]},{"type":"JSONLayoutRow","additionalStyles":[],"additionalClasses":[],"columns":[{"content":[],"widthXS":12,"widthMD":null,"widthSM":null,"widthXL":null,"widthLG":null,"additionalStyles":[],"additionalClasses":[]}]}]},"blackBoard":null,"selectionTranslators":[{"mapping":null,"sourceID":"11b1e519-096c-49d4-a933-8e4a4f7aa179","targetIDs":["d2f86ab8-86f9-4090-a14f-656412cadb35"],"forward":false},{"mapping":null,"sourceID":"d2f86ab8-86f9-4090-a14f-656412cadb35","targetIDs":["7f0acfbf-e8e9-4e21-b934-72f9841f453d"],"forward":false},{"mapping":null,"sourceID":"d2f86ab8-86f9-4090-a14f-656412cadb35","targetIDs":["7f0acfbf-e8e9-4e21-b934-72f9841f453d"],"forward":false},{"mapping":null,"sourceID":"9f507616-ab30-4af4-9f0f-35ef0d66dd39","targetIDs":["d2f86ab8-86f9-4090-a14f-656412cadb35"],"forward":false},{"mapping":null,"sourceID":"c0a7d1a3-cd24-4b4b-8bab-60674d331fba","targetIDs":["a2402966-a263-4220-9113-85a682cc8244"],"forward":false}],"version":"3.7.2.v201904170949"},"webNodes":{"58:0:24":{"@class":"org.knime.js.core.JSONWebNode","namespace":"knime_paged_table","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/knime/knime_table_1_0_0.js","/js-lib/moment/2_17/locales/moment-with-locales.min.js","/js-lib/moment/2_17/timezone/moment-timezone-with-data.min.js","/js-lib/jQuery/jquery-1.11.3.min.js","/js-lib/bootstrap/3_3_6/min/js/bootstrap.min.js","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.js","/js-lib/knime/tableViewer/knime_base_table_viewer_1_0_0.js","/org/knime/js/base/node/viz/pagedTable/knime-paged-table.js"],"getViewValueMethodName":"getComponentValue","customCSS":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\tfont-weight: bold;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n\ttext-decoration: underline;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-style: italic;\n\tfont-size: 16px; \n}\n","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css","/js-lib/bootstrap/3_3_6/min/css/bootstrap.min.css","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.css","/js-lib/knime/tableViewer/knime_table_viewer.css"],"viewValue":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewValue","columnFilterStrings":null,"selectAllIndeterminate":false,"pageSize":0,"currentPage":0,"selection":null,"selectAll":false,"filterString":null,"currentOrder":[],"publishFilter":true,"hideUnselected":false,"publishSelection":true,"subscribeSelection":true,"subscribeFilter":true},"viewRepresentation":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewRepresentation","table":{"@class":"org.knime.js.core.JSONDataTable","id":"a2402966-a263-4220-9113-85a682cc8244","extensions":null,"rows":[{"data":["[All Other External Causes of Injury and Poisoning, QLD, M, INP]",71.0],"rowKey":"Row6"},{"data":["[Accidental Falls, QLD, M, INP]",61.0],"rowKey":"Row9"},{"data":["[Accidental Falls, VIC, M, INP]",52.0],"rowKey":"Row7"},{"data":["[Accidental Falls, NSW, M, INP]",51.0],"rowKey":"Row8"},{"data":["[All Other External Causes of Injury and Poisoning, VIC, M, INP]",33.0],"rowKey":"Row4"},{"data":["[All Other External Causes of Injury and Poisoning, NSW, M, INP]",31.0],"rowKey":"Row5"},{"data":["[Dorsopathies, QLD, M, INP]",22.0],"rowKey":"Row0"},{"data":["[Neurotic Disorders, Personality Disorders, and Oth, QLD, M, INP]",19.0],"rowKey":"Row1"},{"data":["[Cancer, NSW, M, INP]",16.0],"rowKey":"Row2"},{"data":["[Cancer, QLD, M, INP]",15.0],"rowKey":"Row3"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":2,"possibleValues":[["[All Other External Causes of Injury and Poisoning, QLD, M, INP]","[Accidental Falls, QLD, M, INP]","[Accidental Falls, VIC, M, INP]","[Accidental Falls, NSW, M, INP]","[All Other External Causes of Injury and Poisoning, VIC, M, INP]","[All Other External Causes of Injury and Poisoning, NSW, M, INP]","[Dorsopathies, QLD, M, INP]","[Neurotic Disorders, Personality Disorders, and Oth, QLD, M, INP]","[Cancer, NSW, M, INP]","[Cancer, QLD, M, INP]"],null],"containsMissingValues":[false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":10,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null],"maxValues":["[Neurotic Disorders, Personality Disorders, and Oth, QLD, M, INP]",71.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":["[Accidental Falls, NSW, M, INP]",15.0],"colNames":["Pattern","Frequency"],"knimeTypes":["String","Number (integer)"],"colTypes":["string","number"],"colorModels":[],"numExtensions":0}},"enablePageSizeChange":true,"enableClearSelectionButton":true,"pageSizeShowAll":false,"enableClearSortButton":true,"enableGlobalNumberFormat":false,"displayRowColors":false,"enableSearching":false,"displayRowIndex":false,"enableJumpToPage":false,"displayColumnHeaders":true,"initialPageSize":10,"singleSelection":false,"enableHideUnselected":true,"enableColumnSearching":false,"globalNumberFormatDecimals":2,"publishFilterId":null,"allowedPageSizes":[10,25,50,100],"title":"1. Top 10 Frequent Patterns","maxRows":100000,"displayMissingValueAsQuestionMark":true,"enableSorting":true,"fixedHeaders":false,"enablePaging":true,"displayRowIds":false,"subtitle":"[Claim Desc, State, Sex, Claim Type]","subscriptionFilterIds":[],"enableSelection":true,"displayFullscreenButton":true,"dateTimeFormats":{"@class":"org.knime.js.core.components.datetime.SettingsModelDateTimeOptions$JSONDateTimeOptions","globalLocalTimeFormat":"HH:mm:ss","globalDateTimeFormat":"YYYY-MM-DD","globalLocalDateFormat":"YYYY-MM-DD","globalLocalDateTimeFormat":"YYYY-MM-DD","globalZonedDateTimeFormat":"YYYY-MM-DD z","globalDateTimeLocale":"en","timezone":"Australia/Sydney"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Table View (JavaScript)"}},"58:0:35":{"@class":"org.knime.js.core.JSONWebNode","namespace":"knime_paged_table","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/knime/knime_table_1_0_0.js","/js-lib/moment/2_17/locales/moment-with-locales.min.js","/js-lib/moment/2_17/timezone/moment-timezone-with-data.min.js","/js-lib/jQuery/jquery-1.11.3.min.js","/js-lib/bootstrap/3_3_6/min/js/bootstrap.min.js","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.js","/js-lib/knime/tableViewer/knime_base_table_viewer_1_0_0.js","/org/knime/js/base/node/viz/pagedTable/knime-paged-table.js"],"getViewValueMethodName":"getComponentValue","customCSS":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\tfont-weight: bold;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n\tmargin-top: 5px;\n\ttext-decoration: underline;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-style: italic;\n\tfont-size: 16px; \n}\n","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css","/js-lib/bootstrap/3_3_6/min/css/bootstrap.min.css","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.css","/js-lib/knime/tableViewer/knime_table_viewer.css"],"viewValue":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewValue","columnFilterStrings":null,"selectAllIndeterminate":false,"pageSize":0,"currentPage":0,"selection":null,"selectAll":false,"filterString":null,"currentOrder":[],"publishFilter":true,"hideUnselected":false,"publishSelection":true,"subscribeSelection":true,"subscribeFilter":true},"viewRepresentation":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewRepresentation","table":{"@class":"org.knime.js.core.JSONDataTable","id":"a2402966-a263-4220-9113-85a682cc8244","extensions":null,"rows":[{"data":[1.000037265E9,"VIC",0.0,0.0],"rowKey":"Row41"},{"data":[1.000040227E9,"SA",0.0,0.0],"rowKey":"Row51"},{"data":[1.000046801E9,"SA",0.0,0.0],"rowKey":"Row71"},{"data":[1.000050737E9,"VIC",0.0,0.0],"rowKey":"Row82"},{"data":[1.000069278E9,"QLD",0.0,0.0],"rowKey":"Row139"},{"data":[1.000080407E9,"VIC",0.0,0.0],"rowKey":"Row168"},{"data":[1.000084784E9,"QLD",0.0,0.0],"rowKey":"Row179"},{"data":[1.000090723E9,"NSW",0.0,0.0],"rowKey":"Row198"},{"data":[1.00009148E9,"VIC",0.0,0.0],"rowKey":"Row199"},{"data":[1.000098345E9,"QLD",0.0,0.0],"rowKey":"Row216"},{"data":[1.000098394E9,"QLD",0.0,0.0],"rowKey":"Row217"},{"data":[1.000098928E9,"NSW",0.0,0.0],"rowKey":"Row219"},{"data":[1.0001091E9,"VIC",0.0,0.0],"rowKey":"Row253"},{"data":[1.000112597E9,"QLD",0.0,0.0],"rowKey":"Row268"},{"data":[1.000117984E9,"NSW",0.0,0.0],"rowKey":"Row279"},{"data":[1.000189818E9,"VIC",0.0,0.0],"rowKey":"Row287"},{"data":[1.000124617E9,"SA",0.0,0.0],"rowKey":"Row297"},{"data":[1.000131695E9,"NSW",0.0,0.0],"rowKey":"Row314"},{"data":[1.000142127E9,"QLD",0.0,0.0],"rowKey":"Row354"},{"data":[1.000150902E9,"NSW",0.0,0.0],"rowKey":"Row380"},{"data":[1.00015217E9,"QLD",0.0,0.0],"rowKey":"Row385"},{"data":[1.000153721E9,"QLD",0.0,0.0],"rowKey":"Row389"},{"data":[1.00015573E9,"QLD",0.0,0.0],"rowKey":"Row401"},{"data":[1.000156746E9,"VIC",0.0,0.0],"rowKey":"Row405"},{"data":[1.000169364E9,"NSW",0.0,0.0],"rowKey":"Row441"},{"data":[1.000192994E9,"TAS",0.0,0.0],"rowKey":"Row523"},{"data":[1.000194085E9,"VIC",0.0,0.0],"rowKey":"Row527"},{"data":[1.000261396E9,"QLD",0.0,0.0],"rowKey":"Row557"},{"data":[1.000199812E9,"VIC",0.0,0.0],"rowKey":"Row583"},{"data":[1.000206191E9,"NT",0.0,0.0],"rowKey":"Row605"},{"data":[1.000223802E9,"NSW",0.0,0.0],"rowKey":"Row676"},{"data":[1.000229063E9,"NT",0.0,0.0],"rowKey":"Row690"},{"data":[1.00023132E9,"QLD",0.0,0.0],"rowKey":"Row698"},{"data":[1.000243941E9,"QLD",0.0,0.0],"rowKey":"Row740"},{"data":[1.000244593E9,"VIC",0.0,0.0],"rowKey":"Row745"},{"data":[1.000248185E9,"NSW",0.0,0.0],"rowKey":"Row753"},{"data":[1.000274202E9,"VIC",0.0,0.0],"rowKey":"Row821"},{"data":[1.00028329E9,"NSW",0.0,0.0],"rowKey":"Row886"},{"data":[1.000297597E9,"VIC",0.0,0.0],"rowKey":"Row943"},{"data":[1.00029862E9,"VIC",0.0,0.0],"rowKey":"Row949"},{"data":[1.000298656E9,"NSW",0.0,0.0],"rowKey":"Row950"},{"data":[1.00030128E9,"NSW",0.0,0.0],"rowKey":"Row962"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":4,"possibleValues":[null,["VIC","SA","QLD","NSW","TAS","NT"],null,null],"containsMissingValues":[false,false,false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":42,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null,null,null],"maxValues":[1.00030128E9,"VIC",0.0,0.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":[1.000037265E9,"NSW",0.0,0.0],"colNames":["Policy Number","State","Monthly Benefit","Premium Install"],"knimeTypes":["Number (double)","String","Number (double)","Number (double)"],"colTypes":["number","string","number","number"],"colorModels":[],"numExtensions":0}},"enablePageSizeChange":true,"enableClearSelectionButton":true,"pageSizeShowAll":false,"enableClearSortButton":true,"enableGlobalNumberFormat":false,"displayRowColors":false,"enableSearching":true,"displayRowIndex":false,"enableJumpToPage":false,"displayColumnHeaders":true,"initialPageSize":10,"singleSelection":false,"enableHideUnselected":true,"enableColumnSearching":false,"globalNumberFormatDecimals":2,"publishFilterId":null,"allowedPageSizes":[10,25,50,100],"title":"2. Inactive Policyholders","maxRows":100000,"displayMissingValueAsQuestionMark":true,"enableSorting":true,"fixedHeaders":false,"enablePaging":true,"displayRowIds":false,"subtitle":"","subscriptionFilterIds":[],"enableSelection":true,"displayFullscreenButton":true,"dateTimeFormats":{"@class":"org.knime.js.core.components.datetime.SettingsModelDateTimeOptions$JSONDateTimeOptions","globalLocalTimeFormat":"HH:mm:ss","globalDateTimeFormat":"YYYY-MM-DD","globalLocalDateFormat":"YYYY-MM-DD","globalLocalDateTimeFormat":"YYYY-MM-DD","globalZonedDateTimeFormat":"YYYY-MM-DD z","globalDateTimeLocale":"en","timezone":"Australia/Sydney"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Table View (JavaScript)"}},"58:0:46":{"@class":"org.knime.js.core.JSONWebNode","namespace":"knime_paged_table","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/knime/knime_table_1_0_0.js","/js-lib/moment/2_17/locales/moment-with-locales.min.js","/js-lib/moment/2_17/timezone/moment-timezone-with-data.min.js","/js-lib/jQuery/jquery-1.11.3.min.js","/js-lib/bootstrap/3_3_6/min/js/bootstrap.min.js","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.js","/js-lib/knime/tableViewer/knime_base_table_viewer_1_0_0.js","/org/knime/js/base/node/viz/pagedTable/knime-paged-table.js"],"getViewValueMethodName":"getComponentValue","customCSS":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\tfont-weight: bold;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n\tmargin-top: 5px;\n\ttext-decoration: underline;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-style: italic;\n\tfont-size: 16px; \n}\n","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css","/js-lib/bootstrap/3_3_6/min/css/bootstrap.min.css","/js-lib/dataTables/1_10_11/bootstrap/datatables.min.css","/js-lib/knime/tableViewer/knime_table_viewer.css"],"viewValue":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewValue","columnFilterStrings":null,"selectAllIndeterminate":false,"pageSize":0,"currentPage":0,"selection":null,"selectAll":false,"filterString":null,"currentOrder":[],"publishFilter":true,"hideUnselected":false,"publishSelection":true,"subscribeSelection":true,"subscribeFilter":true},"viewRepresentation":{"@class":"org.knime.js.base.node.viz.pagedTable.PagedTableViewRepresentation","table":{"@class":"org.knime.js.core.JSONDataTable","id":"a2402966-a263-4220-9113-85a682cc8244","extensions":null,"rows":[{"data":[1.000037265E9,10000.0,0.0],"rowKey":"Row42"},{"data":[1.000038841E9,3000.0,0.0],"rowKey":"Row49"},{"data":[1.00004144E9,3278.54,0.0],"rowKey":"Row57"},{"data":[1.000044713E9,6259.25,0.0],"rowKey":"Row62"},{"data":[1.000048792E9,5276.32,0.0],"rowKey":"Row76"},{"data":[1.000050348E9,2343.0,0.0],"rowKey":"Row78"},{"data":[1.000052503E9,5313.75,0.0],"rowKey":"Row85"},{"data":[1.00005519E9,3356.99,0.0],"rowKey":"Row91"},{"data":[1.000062491E9,8574.03,0.0],"rowKey":"Row119"},{"data":[1.000068766E9,2554.29,0.0],"rowKey":"Row137"},{"data":[1.000070311E9,3898.23,0.0],"rowKey":"Row143"},{"data":[1.000070591E9,8507.19,0.0],"rowKey":"Row144"},{"data":[1.000075746E9,734.0,0.0],"rowKey":"Row159"},{"data":[1.00008199E9,6003.0,0.0],"rowKey":"Row171"},{"data":[1.00009179E9,3168.97,0.0],"rowKey":"Row201"},{"data":[1.000095964E9,5918.88,0.0],"rowKey":"Row208"},{"data":[1.000098011E9,3686.92,0.0],"rowKey":"Row215"},{"data":[1.000104503E9,4977.38,0.0],"rowKey":"Row243"},{"data":[1.00010535E9,2699.93,0.0],"rowKey":"Row245"},{"data":[1.000108314E9,3763.78,0.0],"rowKey":"Row251"},{"data":[1.00010924E9,5159.96,0.0],"rowKey":"Row254"},{"data":[1.000110618E9,4917.92,0.0],"rowKey":"Row258"},{"data":[1.000111842E9,1998.0,0.0],"rowKey":"Row264"},{"data":[1.0001248E9,2962.53,0.0],"rowKey":"Row298"},{"data":[1.000135391E9,3187.57,0.0],"rowKey":"Row334"},{"data":[1.00013779E9,2407.92,0.0],"rowKey":"Row340"},{"data":[1.000140271E9,5419.72,0.0],"rowKey":"Row349"},{"data":[1.000142528E9,2387.0,0.0],"rowKey":"Row357"},{"data":[1.000151165E9,2897.7,0.0],"rowKey":"Row381"},{"data":[1.000152546E9,4277.06,0.0],"rowKey":"Row386"},{"data":[1.000154567E9,2500.0,0.0],"rowKey":"Row394"},{"data":[1.000172648E9,7227.03,0.0],"rowKey":"Row452"},{"data":[1.000176897E9,4077.92,0.0],"rowKey":"Row469"},{"data":[1.000183798E9,7029.68,0.0],"rowKey":"Row500"},{"data":[1.000189818E9,4297.76,0.0],"rowKey":"Row514"},{"data":[1.00019226E9,2979.23,0.0],"rowKey":"Row518"},{"data":[1.000193329E9,3172.4,0.0],"rowKey":"Row525"},{"data":[1.000198376E9,7112.73,0.0],"rowKey":"Row542"},{"data":[1.000199241E9,6626.55,0.0],"rowKey":"Row544"},{"data":[1.000209209E9,2247.12,0.0],"rowKey":"Row615"},{"data":[1.000211836E9,2715.32,0.0],"rowKey":"Row622"},{"data":[1.000218405E9,3398.0,0.0],"rowKey":"Row656"},{"data":[1.000226955E9,5000.0,0.0],"rowKey":"Row683"},{"data":[1.00024846E9,3219.17,0.0],"rowKey":"Row759"},{"data":[1.000250532E9,3125.0,0.0],"rowKey":"Row771"},{"data":[1.000251147E9,3054.21,0.0],"rowKey":"Row775"},{"data":[1.00027424E9,2975.1,0.0],"rowKey":"Row822"},{"data":[1.000274329E9,1606.96,0.0],"rowKey":"Row828"},{"data":[1.000274329E9,5788.08,0.0],"rowKey":"Row829"},{"data":[1.0002745E9,7159.39,0.0],"rowKey":"Row833"},{"data":[1.000338769E9,4160.03,0.0],"rowKey":"Row852"},{"data":[1.000340892E9,2187.0,0.0],"rowKey":"Row862"},{"data":[1.000341276E9,4053.59,0.0],"rowKey":"Row863"},{"data":[1.000280998E9,5169.96,0.0],"rowKey":"Row877"},{"data":[1.000282545E9,18589.68,0.0],"rowKey":"Row882"},{"data":[1.00029044E9,3386.54,0.0],"rowKey":"Row916"},{"data":[1.000299089E9,13112.12,0.0],"rowKey":"Row951"},{"data":[1.00030355E9,3873.0,0.0],"rowKey":"Row972"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":3,"possibleValues":[null,null,null],"containsMissingValues":[false,false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":58,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null,null],"maxValues":[1.000341276E9,18589.68,0.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":[1.000037265E9,734.0,0.0],"colNames":["Policy Number","Monthly Benefit","Premium Install"],"knimeTypes":["Number (double)","Number (double)","Number (double)"],"colTypes":["number","number","number"],"colorModels":[],"numExtensions":0}},"enablePageSizeChange":true,"enableClearSelectionButton":true,"pageSizeShowAll":false,"enableClearSortButton":true,"enableGlobalNumberFormat":false,"displayRowColors":false,"enableSearching":true,"displayRowIndex":false,"enableJumpToPage":false,"displayColumnHeaders":true,"initialPageSize":10,"singleSelection":false,"enableHideUnselected":true,"enableColumnSearching":false,"globalNumberFormatDecimals":2,"publishFilterId":null,"allowedPageSizes":[10,25,50,100],"title":"3. Monthly Benefiters Paying 0 Premium ","maxRows":100000,"displayMissingValueAsQuestionMark":true,"enableSorting":true,"fixedHeaders":false,"enablePaging":true,"displayRowIds":false,"subtitle":"","subscriptionFilterIds":[],"enableSelection":true,"displayFullscreenButton":true,"dateTimeFormats":{"@class":"org.knime.js.core.components.datetime.SettingsModelDateTimeOptions$JSONDateTimeOptions","globalLocalTimeFormat":"HH:mm:ss","globalDateTimeFormat":"YYYY-MM-DD","globalLocalDateFormat":"YYYY-MM-DD","globalLocalDateTimeFormat":"YYYY-MM-DD","globalZonedDateTimeFormat":"YYYY-MM-DD z","globalDateTimeLocale":"en","timezone":"Australia/Sydney"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Table View (JavaScript)"}},"58:0:48":{"@class":"org.knime.js.core.JSONWebNode","namespace":"dynamicJSNode","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/requireJS/2.1.8/require.js","/js-lib/knime/knime_table_1_0_0.js","/org/knime/dynamic/js/dynamicJSNode.js"],"getViewValueMethodName":"getComponentValue","customCSS":"","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css"],"viewValue":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewValue","options":{"includeMissValCat":true,"togglePie":false,"insideTitle":"","showLabels":true,"subtitle":"Monthly Benefiters Paying 0 Premium","freq":"Premium Install","labelType":"Percent","title":"State-wise Breakdown","subscribeToSelection":true,"publishSelection":true,"holeSize":0.35},"tables":{},"outColumns":{},"flowVariables":{}},"viewRepresentation":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewRepresentation","runningInView":true,"options":{"displayFullscreenButton":true,"displayClearSelectionButton":true,"enableHoleEdit":true,"svg":{"width":600,"height":400,"fullscreen":false},"legend":true,"enableInsideTitleEdit":true,"customColors":false,"enableTitleEdit":true,"enableSelection":true,"enableDonutToggle":true,"enableLabelEdit":true,"enableSwitchMissValCat":true,"processInMemory":true,"reportOnMissingValues":true,"labelThreshold":0.05,"cat":"State","enableViewControls":true,"enableColumnChooser":true,"showWarnings":true,"enableSubtitleEdit":true,"aggr":"OccurenceÂ Count"},"cssDependencies":["js-lib/nvd3/nv.d3.v1_8_1.min.css"],"jsDependencies":[{"name":"nvd3","path":"js-lib/nvd3/nv.d3.v1_8_1.min.js","dependencies":["D3_3.5.5"],"local":true,"usesDefine":false,"exports":"nv"},{"name":"D3_3.5.5","path":"js-lib/d3/d3.v3_5_5.min.js","dependencies":[],"local":true,"usesDefine":false,"exports":null}],"errorMessage":"","binaryFiles":{},"inObjects":[{"table":{"@class":"org.knime.js.core.JSONDataTable","id":"5e22b191-38f4-402b-8881-7cd68ccf4dfd","extensions":null,"rows":[{"data":["VIC",15.0],"rowKey":"Row0"},{"data":["NSW",13.0],"rowKey":"Row1"},{"data":["SA",6.0],"rowKey":"Row2"},{"data":["QLD",18.0],"rowKey":"Row3"},{"data":["WA",5.0],"rowKey":"Row4"},{"data":["TAS",1.0],"rowKey":"Row5"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":2,"possibleValues":[["VIC","NSW","SA","QLD","WA","TAS"],null],"containsMissingValues":[false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":6,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null],"maxValues":["WA",18.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":["NSW",1.0],"colNames":["State","State_1"],"knimeTypes":["String","Number (integer)"],"colTypes":["string","number"],"colorModels":[],"numExtensions":0}},"uuid":"f6aea757-ee07-4ade-8ada-70a5b4ac091d","translator":{"mapping":{"Row0":["Row62","Row76","Row42","Row171","Row394","Row386","Row882","Row334","Row972","Row159","Row852","Row215","Row656","Row514","Row877"],"Row1":["Row208","Row615","Row518","Row49","Row78","Row251","Row264","Row144","Row254","Row683","Row542","Row862","Row469"],"Row4":["Row828","Row829","Row201","Row258","Row349"],"Row5":["Row340"],"Row2":["Row381","Row243","Row57","Row500","Row775","Row622"],"Row3":["Row85","Row759","Row916","Row91","Row143","Row298","Row452","Row771","Row245","Row137","Row357","Row544","Row863","Row951","Row525","Row822","Row833","Row119"]},"sourceID":null,"targetIDs":null,"forward":false}}],"jsNamespace":"pie_chart_namespace","warnMessage":"","tableIds":["a2402966-a263-4220-9113-85a682cc8244"],"jsCode":["(pie_chart_namespace = function() {\n\n\tvar pie = {};\n\tvar _representation, _value;\n\tvar layoutContainer;\n\tvar MIN_HEIGHT = 100, MIN_WIDTH = 100;\n\tvar chart, svg;\n\tvar knimeTable;\n\t\n\tvar plotData;\n\tvar colorRange;\n\tvar excludeCat;\n\tvar missValCatValue;\n    var _translator;\n    var _keyNameMap;\n    var _incomingTable;\n\t\n\tvar showWarnings;\n\t\n\tvar MISSING_VALUES_ONLY = \"missingValuesOnly\";\n\tvar NO_DATA_AVAILABLE = \"noDataAvailable\";\n\n\tpie.init = function(representation, value) {\n\t\t_representation = representation;\n\t\t_value = value;\n\t\t_incomingTable = _representation.inObjects[0].table;\n\t\t\n\t\tif(_representation.options.enableSelection && _representation.inObjects[0].translator) {\n        \t_translator = _representation.inObjects[0].translator;\n        \t_translator.sourceID = _representation.inObjects[0].uuid;\n        \t_translator.targetIDs = [_representation.tableIds[0]];\n        \tknimeService.registerSelectionTranslator(_translator, _translator.sourceID);\n        \tsubscribeToSelection(_value.options.subscribeToSelection);\n        }\n\t\t\n\t\tshowWarnings = _representation.options.showWarnings;\n\t\t\n\t\tif (_representation.warnMessage && showWarnings) {\n\t\t\tknimeService.setWarningMessage(_representation.warnMessage);\n\t\t}\n\n\t\tdrawChart(false);\n\t\tif (_representation.options.enableViewControls) {\n\t\t\tdrawControls();\n\t\t}\n\t\t_keyNameMap = new KeyNameMap(getClusterToRowMapping());\n\t}\n\n\tfunction drawChart(redraw) {\t\t\n\t\t// Parse the options\n\t\tvar optTitle = _value.options[\"title\"];\n\t\tvar optSubtitle = _value.options[\"subtitle\"];\n\n\t\tvar showLabels = _value.options[\"showLabels\"];\n\t\tvar labelThreshold = _representation.options[\"labelThreshold\"];\n\t\tvar labelType = _value.options[\"labelType\"].toLowerCase();\n\t\t\t\t\n\t\tvar optDonutChart = _value.options[\"togglePie\"];\n\t\tvar holeSize = _value.options[\"holeSize\"];\n\t\tvar optInsideTitle = _value.options[\"insideTitle\"];\n\n\t\tvar showLegend = _representation.options[\"legend\"];\n\n\t\tvar optFullscreen = _representation.options[\"svg\"][\"fullscreen\"] && _representation.runningInView;\n\t\tvar optWidth = _representation.options[\"svg\"][\"width\"]\n\t\tvar optHeight = _representation.options[\"svg\"][\"height\"]\n\t\t\n\t\tvar optEnableSelection = _representation.options['enableSelection'];\n\t\t\n\t\tvar isTitle = optTitle || optSubtitle;\n\n\t\t/*\n\t\t * Setup interactive controls\n\t\t */\n\t\t\n\t\td3.select(\"html\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n        d3.select(\"body\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n\n\t\tvar body = d3.select(\"body\");\n\n\t\tvar width = optWidth + \"px\";\n\t\tvar height = optHeight + \"px\";\n\t\tif (optFullscreen) {\n\t\t\twidth = \"100%\";\n\t\t\theight = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t}\n\t\t\n\t\tvar div;\n\t\tif (redraw) {\n\t\t\td3.select(\"svg\").remove();\n\t\t\tdiv = d3.select(\"#svgContainer\");\n\t\t} else {\n\t\t\tlayoutContainer = body.append(\"div\")\n\t\t\t\t.attr(\"id\", \"layoutContainer\")\n\t\t\t\t.attr('class', 'knime-layout-container')\t\t\t\t\n\t\t\t\t.style(\"width\", width)\n\t\t\t\t.style(\"height\", height)\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\t\t\n\t\t\t\n\t\t\tdiv = layoutContainer.append(\"div\")\n\t\t\t\t.attr(\"id\", \"svgContainer\")\n\t\t\t\t.attr('class', 'knime-svg-container')\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\n\t\t}\n\n\t\t/*\n\t\t * Process data\n\t\t */\n\t\tknimeTable = new kt();\n\t\t// Add the data from the input port to the knimeTable.\n\t\tvar port0dataTable = _representation.inObjects[0].table;\n\t\tport0dataTable.rows = sortByClusterName(port0dataTable.rows);\n\t\tknimeTable.setDataTable(port0dataTable);\n\t\t\n\t\tprocessData(true);\t\n\t\tsetColorRange();\n\t\t\n\t\t// Create the SVG object\n\t\tvar svg1 = document\n\t\t\t\t.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tdiv[0][0].appendChild(svg1);\n\n\t\tsvg = d3.select(\"svg\")\n\t\t\t.style(\"display\", \"block\");\n\n\t\tif (!optFullscreen) {\n\t\t\tif (optWidth > 0) {\n\t\t\t\tdiv.style(\"width\", optWidth + \"px\")\n\t\t\t\tsvg.attr(\"width\", optWidth);\n\t\t\t}\n\t\t\tif (optHeight > 0) {\n\t\t\t\tsvg.attr(\"height\", optHeight);\n\t\t\t\tdiv.style(\"height\", optHeight + \"px\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Set full screen height/width\n\t\t\tdiv.style(\"width\", \"100%\");\n\t\t\tdiv.style(\"height\", height);\n\n\t\t\tsvg.attr(\"width\", \"100%\");\n\t\t\tsvg.attr(\"height\", \"100%\");\n\t\t}\n\t\n\t\t// Pie chart\n\t\tnv.addGraph(function() {\n\t\t\tchart = nv.models.pieChart()\n\t\t\t\t.x(function(d) { return d.label })\n\t\t\t\t.y(function(d) { return d.value })\n\t\t\t\t.color(colorRange)\n\t\t\t\t.duration(0)\n\t\t\t\t.showLegend(showLegend)\n\t\t\t\t.showLabels(showLabels)\n\t\t\t\t.labelThreshold(labelThreshold) \n\t\t\t\t.labelType(labelType); // \"key\", \"value\" or \"percent\"\n\n\t\t\tchart.dispatch.on('renderEnd.css', function() {\n\t\t\t\tsetCssClasses();\n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t// tooltip is re-created every time therefore we need to assign classes accordingly\n\t\t\tchart.pie.dispatch.on('elementMouseover.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.pie.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.legend.dispatch.on('legendClick', function(series, index) {\n            \t//drawChart(true);\n            \tremoveHilightBar(\"\",true);\n            \td3.event.stopPropagation();\n            });\n\t\t\t\n\t\t\tchart.width(optFullscreen ? \"100%\" : optWidth);\n\t\t\tchart.height(optFullscreen ? \"100%\" : optHeight);\n\t\t\tchart.margin({top: 0, bottom: 0, left: 20, right: 0});\n\n\t\t\t// TODO: Add a mechanism to remember the categories that are\n\t\t\t// switched on.\n\n\t\t\tchart.donut(optDonutChart);\n\t\t\tchart.donutRatio(holeSize);\n\t\t\tif (optInsideTitle) {\n\t\t\t\tchart.title(optInsideTitle);\n\t\t\t}\n\t\t\tupdateTitles(false);\n\n\t\t\t// checking if all the pies are 0s\n\t\t\tif (plotData.filter(function(d) { return d.value !== 0 }).length === 0) {\n\t\t\t\tsvg.append('text')\n\t\t\t\t\t.attr('x', 20)\n\t\t\t\t\t.attr('y', 80)\n\t\t\t\t\t.attr('font-size', 20)\n\t\t\t\t\t.attr('fill', 'red')\n\t\t\t\t\t.text('The plot is empty because all values are equal to 0.');\n\t\t\t} else {\n\t\t\t\tsvg.datum(plotData).transition().duration(0).call(chart);\n\t\t\t}\n\t\t\t//nv.utils.windowResize(chart.update);\n\t\t\tnv.utils.windowResize(function () { \n\t\t\t\tchart.update(); \n\t\t\t\tremoveHilightBar(\"\",true); \n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t\n\t\t\tif(optEnableSelection) {\n\t\t\t\tsvg.on(\"click\", function() {\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t_value.options['selection'] = [];\n\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// redraws selection\n            redrawSelection();\n\n\t\t\treturn chart;\n\t\t});\n\t}\n\t\n    function sortByClusterName(array) {\n        return array.sort(function(a, b) {\n            var x = a.data[0];\n            var y = b.data[0];\n            \n            // Make sure, that missing values are displayed last\n            if(x == null) {\n            \treturn 1\n            } else if (y == null) {\n            \treturn -1;\n            }\n            \n            if (typeof x == \"string\")\n            {\n                x = (\"\"+x).toLowerCase(); \n            }\n            if (typeof y == \"string\")\n            {\n                y = (\"\"+y).toLowerCase();\n            }\n            return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n        });\n    }\n\t\n    function registerClickHandler () {\n        d3.selectAll(\".nv-slice\").on('click',function(event) {\n            handleHighlightClick(event);\n            d3.event.stopPropagation();\n        });\n    }\n\n    function redrawSelection() {\n        var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n        for (var i = 0; i < length; i++) {\n            createHilightBar(_keyNameMap.getNameFromKey(_value.options['selection'][i][0]), \n                _value.options['selection'][i][1]);\n        }\n    }\n\n    function subscribeToSelection(subscribeBool) {\n        if(_representation.options.enableSelection) {\n            if(subscribeBool) {\n                knimeService.subscribeToSelection(_translator.sourceID, onSelectionChanged);\n            } else {\n                knimeService.unsubscribeSelection(_translator.sourceID, onSelectionChanged);\n            }\n        }\n    }\n\n    function publishSelection(shouldPublish){\n        if(shouldPublish) {\n            knimeService.setSelectedRows(_translator.sourceID, getSelectedRowIDs(), _translator.sourceID);\n        }\n    }\n\n    function checkClearSelectionButton(){\n        var button = d3.select(\"#clearSelectionButton\");\n        if (button){\n            button.classed(\"inactive\", function(){return !_value.options['selection'].length > 0});\n        }\n    }\n\n    function getSelectedRowIDs() {\n        if(_value.options['selection']) {\n            var selectedRowIDs = [];\n            for (var i = 0; i< _value.options['selection'].length; i++) {\n                selectedRowIDs.push( _value.options['selection'][i][0]);\n            }\n            return selectedRowIDs;\n        } else {\n            return [];\n        }\n    }\n\n    // Removes the clusterName with the given cluster name. If \"removeAll\" is true all bars are removed\n    function removeHilightBar(clusterName, removeAll) {\n        if (removeAll) {\n            var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n            for (var i = 0; i < length; i++) {\n                d3.selectAll(\".hilightBar\").remove();\n            }\n        } else {\n            var barIndex = getSelectedRowIDs().indexOf(_keyNameMap.getKeyFromName(clusterName));\n            if(barIndex > -1) {\n                let pie = selectCorrectBar(clusterName);\n                if (pie){\n                    pie.remove();\n                }\n            }\n        }\n    } \n\n    function selectCorrectBar(clusterName) {\n        let allSlices = d3.selectAll(\".nv-slice\");\n        for(var j = 0; j < allSlices[0].length; j++) {\n            if(d3.select(allSlices[0][j]).data()[0].data.label == clusterName) {\n                return d3.select(allSlices[0][j]).select(\".hilightBar\");\n            }\n        }\n    }\n\n    // Create a hilight-bar above the cluster with the given name and assigns the given css class to it\n    function createHilightBar (clusterName, selectionClass) {\n        for(var j = 0; j < plotData.length; j++) {\n            if(plotData[j].label === clusterName) {\n                var slices = d3.selectAll(\".nv-slice\");\n                for(var i = 0; i < slices[0].length; i++) {\n                    if(i==j) {\n                        var slice = d3.select(slices[0][i]).select(\"path\");\n                        var availableWidth = chart.width() - 20;\n                        var availableHeight = chart.height();\n                        var radius = Math.min(availableWidth, availableHeight) / 2;\n                        var selectionTitle;\n                        if(selectionClass == \"knime-selected\") {\n                            selectionTitle = \"Selected\";\n                        } else {\n                            selectionTitle = \"Partially selected\";\n                        }\n                        //PieChart Code\n                        var arc = d3.svg.arc()\n                        .innerRadius((radius - radius / 5))\n                        .outerRadius((radius - radius / 5)+8)\n                        .startAngle(slice.data()[0].startAngle) //converting from degs to radians\n                        .endAngle(slice.data()[0].endAngle); //just radians\n\n                        slice.select(function() { return this.parentNode; }).append(\"path\")\n                        .attr(\"d\", arc)\n                        .classed(\"hilightBar\",true)\n                        .classed(selectionClass, true)\n                        .append(\"title\")\n                        .classed('knime-tooltip', true)\n                        .text(selectionTitle);\n                    } \n                }\n            }\n        }\n    }\n\n    function getClusterToRowMapping() {\n        var map = {};\n        for (var i = 0; i < _incomingTable.rows.length; i++) {\n            if(_incomingTable.rows[i].data[0]) {\n                map[_incomingTable.rows[i].data[0]] = _incomingTable.rows[i].rowKey;\n            } else {\n                map[\"Missing values\"] = _incomingTable.rows[i].rowKey;\n            }\n        }\n        return map;\n    }\n\n    // Helper class to handle conversion from cluster name to row key\n    function KeyNameMap(map) {\n        this.map = map;\n        this.reverseMap = {};\n        for(var key in map){\n            var value = map[key];\n            this.reverseMap[value] = key;   \n        }\n    }\n\n    KeyNameMap.prototype.getKeyFromName = function(name){ \n        return this.map[name]; \n    }\n    KeyNameMap.prototype.getNameFromKey = function(key){\n        return this.reverseMap[key];\n    }\n\n    function handleHighlightClick(event) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        var clusterName = event.data.label;\n        var clusterKey = _keyNameMap.getKeyFromName(clusterName);\n        var barIndex = getSelectedRowIDs().indexOf(clusterKey);\n        // Deselect already selected bar when clicking again on it\n        if(barIndex > -1 && (d3.event.ctrlKey || d3.event.shiftKey || d3.event.metaKey)){\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.removeRowsFromSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, false);\n            _value.options['selection'].splice(barIndex, 1);\n        } else if(!d3.event.ctrlKey && !d3.event.shiftKey && !d3.event.metaKey) {\n            // Deselect all previously selected bars and select the newly clicked one\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.setSelectedRows(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, true);\n            _value.options['selection']= [];\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        } else {\n            // Select the clicked bar, as it is either a new selection or a additional selection\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.addRowsToSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        }\n        checkClearSelectionButton();\n    }\n\n    function onSelectionChanged(data) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        if (data.reevaluate) {\n            removeHilightBar(\"\", true);\n            var selectedRows = knimeService.getAllRowsForSelection(_translator.sourceID);\n            var partiallySelectedRows = knimeService.getAllPartiallySelectedRows(_translator.sourceID);\n            _value.options['selection'] = [];\n            for (let selectedRow in selectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [selectedRows[selectedRow], \"knime-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(selectedRows[selectedRow]),\n                \"knime-selected\");\n            }\n            for (let partiallySelectedRow in partiallySelectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [partiallySelectedRows[partiallySelectedRow], \"knime-partially-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(partiallySelectedRows[partiallySelectedRow]),\n                \"knime-partially-selected\");\n            }\n        } else if (data.changeSet) {\n            if (data.changeSet.removed) {\n                data.changeSet.removed.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if(data.changeSet.partialRemoved) {\n                data.changeSet.partialRemoved.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if (data.changeSet.added) {\n                data.changeSet.added.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-selected\");\n                    }\n                });\n            }\n            if(data.changeSet.partialAdded) {\n                data.changeSet.partialAdded.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-partially-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-partially-selected\");\n                    }\n                });\n            }\n        }\n        checkClearSelectionButton();\n    }\n\n\t\n\tfunction updateData(updateChart) {\n\t\tprocessData();\n\t\tif (updateChart) {\n\t\t\tchart.update();\n\t\t}\n\t}\n\t\n\tfunction updateTitles(updateChart) {\n\t\tif (chart) {\n\t\t\tvar curTitle = d3.select(\"#title\");\n\t\t\tvar curSubtitle = d3.select(\"#subtitle\");\n\t\t\tvar chartNeedsUpdating = curTitle.empty() != !(_value.options.title) \n\t\t\t\t|| curSubtitle.empty() != !(_value.options.subtitle);\n\t\t\tif (!_value.options.title) {\n\t\t\t\tcurTitle.remove();\n\t\t\t}\n\t\t\tif (_value.options.title) {\n\t\t\t\tif (curTitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", 30)\n\t\t\t\t\t\t.attr(\"id\", \"title\")\n\t\t\t\t\t\t.attr('class', 'knime-title')\n\t\t\t\t\t\t.text(_value.options.title);\n\t\t\t\t} else {\n\t\t\t\t\tcurTitle.text(_value.options.title);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_value.options.subtitle) {\n\t\t\t\tcurSubtitle.remove();\n\t\t\t} \n\t\t\tif (_value.options.subtitle) {\n\t\t\t\tif (curSubtitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20)\n\t\t\t\t\t\t.attr(\"id\", \"subtitle\")\n\t\t\t\t\t\t.attr('class', 'knime-subtitle')\n\t\t\t\t\t\t.text(_value.options.subtitle);\n\t\t\t\t} else {\n\t\t\t\t\tcurSubtitle.text(_value.options.subtitle)\n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar topMargin = 10;\n\t\t\ttopMargin += _value.options.title ? 10 : 0;\n\t\t\ttopMargin += _value.options.subtitle ? 8 : 0;\n\t\t\tchart.legend.margin({top: topMargin, bottom: topMargin});\n\t\t\tchart.margin({top: topMargin, bottom: topMargin});\n\t\t\t\n\t\t\tvar isTitle = _value.options.title || _value.options.subtitle;\n\t\t\tknimeService.floatingHeader(isTitle);\t\t\t\n\t\t\n\t\t\t\n\t\t\tif (updateChart && chartNeedsUpdating) {\n\t\t\t\tif (_representation.options.svg.fullscreen && _representation.runningInView ) {\n\t\t\t\t\tvar height = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t\t\t\tlayoutContainer.style(\"height\", height)\n\t\t\t\t\t\t// two rows below force to invalidate the container which solves a weird problem with vertical scroll bar in IE\n\t\t\t\t\t\t.style('display', 'none')\n\t\t\t\t\t\t.style('display', 'block');\n\t\t\t\t\td3.select(\"#svgContainer\").style(\"height\", height); \n\t\t\t\t}\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprocessData = function(setColorRange) {\n\t\tvar optMethod = _representation.options[\"aggr\"];\n\t\tvar optCat = _representation.options[\"cat\"];\n\t\tvar optFreqCol = _value.options[\"freq\"];\n\t\t\n\t\tvar categories = knimeTable.getColumn(optCat);\n\t\t\n\t\tvar valCol;\n\t\tif (optMethod == \"Occurence\\u00A0Count\") {\n\t\t\tvalCol = knimeTable.getColumn(1);\n\t\t} else {\n\t\t\tvalCol = knimeTable.getColumn(optFreqCol);\n\t\t}\n\t\t\n\t\tplotData = [];\n\t\texcludeCat = [];\n\t\tmissValCatValue = undefined;\n\t\tif (valCol.length > 0) {\n\t\t\tvar numDataPoints = valCol.length;\n\t\t\tfor (var i = 0; i < numDataPoints; i++) {\n\t\t\t\tvar label = categories[i];\n\t\t\t\tvar value = valCol[i];\n\t\t\t\t\n\t\t\t\tif (label === null) {\n\t\t\t\t\t// missing values category\t\t\t\t\t\n\t\t\t\t\t// save the value to append as the last item\t\t\t\t\t\t\n\t\t\t\t\tmissValCatValue = value;\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value === null) {\n\t\t\t\t\t// category has only missing values - exclude it\n\t\t\t\t\texcludeCat.push(label);\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar plotStream = {\n\t\t\t\t\t\"label\" : label,\n\t\t\t\t\t\"value\" : Math.abs(value)  // take abs value to prevent a damaged plot\n\t\t\t\t};\t\t\t\t\n\t\t\t\tplotData.push(plotStream);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprocessMissingValues(false);\n\t}\n\t\n\tsetColorRange = function() {\n\t\tvar numCat = plotData.length;\n\t\tif (missValCatValue !== undefined && missValCatValue !== null) {\n\t\t\t// We don't want the option \"includeMissValCat\" to influence on the number of categories,\n\t\t\t// because the option can be changed in the view and the color scale then can also be changed (if a border case) - and we don't want this.\n\t\t\t// Hence, only the real value matters.\n\t\t\tnumCat++;\n\t\t}\n\t\tif (_representation.options.customColors) {\n\t\t\tcolorRange = [];\n\t\t\tfor (var i = 0; i < numCat; i++) {\n\t\t\t\tvar color = knimeTable.getRowColors()[i];\n\t\t\t\tif (!color) {\n\t\t\t\t\tcolor = \"#7C7C7C\";\n\t\t\t\t}\n\t\t\t\tcolorRange.push(color);\n\t\t\t}\n\t\t} else {\n\t\t\tvar colorScale;\n\t\t\tif (numCat > 10) {\n\t\t\t\tcolorScale = d3.scale.category20();\n\t\t\t} else {\n\t\t\t\tcolorScale = d3.scale.category10();\n\t\t\t}\n\t\t\tcolorRange = colorScale.range();\n\t\t}\n\t}\n\t\n\t/**\n\t * switched - if the chart update was triggered by changing the \"include 'Missing values' category\" option in the view\n\t */\n\tprocessMissingValues = function(switched) {\n\t\t// Missing values post-processing\t\n\t\tif (missValCatValue !== undefined) {  // undefined means there's no missing value in the category column at all\n\t\t\tif (_value.options.includeMissValCat && _representation.options.reportOnMissingValues) {\n\t\t\t\t// add missing values category\n\t\t\t\tvar label = \"Missing values\";\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.push({\"label\": label, \"value\": missValCatValue});\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.push(label);\n\t\t\t\t}\n\t\t\t} else if (switched) {\n\t\t\t\t// remove missing values category, but only if we have triggered switch from the view\n\t\t\t\t// otherwise there's nothing to remove yet\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.pop();\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set warning messages\n\t\tif (!showWarnings) {\n\t\t\treturn;\n\t\t}\n\t\tif (plotData.length == 0) {\n\t\t\t// No data available warnings\n\t\t\tvar str;\n\t\t\tif (missValCatValue !== undefined && missValCatValue !== null && _representation.options.reportOnMissingValues) {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values.\\nThere are values where the category name is missing.\\nTo see them switch on the option \\\"Include 'Missing values' category\\\" in the view settings.\";\n\t\t\t} else {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values or empty.\\nRe-run the workflow with different data.\";\n\t\t\t}\n\t\t\tknimeService.setWarningMessage(str, NO_DATA_AVAILABLE);\n\t\t} else if (excludeCat.length > 0 && _representation.options.reportOnMissingValues) {\n\t\t\tknimeService.setWarningMessage(\"Categories '\" + excludeCat.join(\"', '\") + \"' have only missing values in the frequency column and were excluded from the view.\", MISSING_VALUES_ONLY)\n\t\t} else {\n\t\t\tknimeService.clearWarningMessage(MISSING_VALUES_ONLY);\n\t\t}\t\n\t}\n\t\t\n\tdrawControls = function() {\t\t\n\t\tif (!knimeService) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (_representation.options.displayFullscreenButton) {\n\t\t\tknimeService.allowFullscreen();\n\t\t}\n\t\t\n\t    if (!_representation.options.enableViewControls) return;\n\t    \n\t    var titleEdit = _representation.options.enableTitleEdit;\n\t\tvar subtitleEdit = _representation.options.enableSubtitleEdit;\n\t\tvar donutToggle = _representation.options.enableDonutToggle;\n\t\tvar holeEdit = _representation.options.enableHoleEdit;\n\t\t//var insideTitleEdit = _representation.options.enableInsideTitleEdit;\n\t\t//var colChooser = _representation.options.enableColumnChooser;\n\t\tvar labelEdit = _representation.options.enableLabelEdit;\n\t\tvar switchMissValCat = _representation.options.enableSwitchMissValCat;\n\t\tvar enableSelection = _representation.options.enableSelection;\n\t\tvar displayClearButton = _representation.options.displayClearSelectionButton;\n\t    \n\t    if (titleEdit || subtitleEdit) {\t    \t    \n\t    \tif (titleEdit) {\n\t    \t\tvar chartTitleText = knimeService.createMenuTextField('chartTitleText', _value.options.title, function() {\n\t    \t\t\tif (_value.options.title != this.value) {\n\t\t\t\t\t\t_value.options.title = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tknimeService.addMenuItem('Chart Title:', 'header', chartTitleText);\n\t    \t}\n\t    \tif (subtitleEdit) {\n\t    \t\tvar chartSubtitleText = knimeService.createMenuTextField('chartSubtitleText', _value.options.subtitle, function() {\n\t    \t\t\tif (_value.options.subtitle != this.value) {\n\t\t\t\t\t\t_value.options.subtitle = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tvar mi = knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null, knimeService.SMALL_ICON);\n\t    \t}\t\n\t    \tif (/*colChooser ||*/ labelEdit || donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    /*if (colChooser) {\n\t    \t// filter out non number columns\n\t    \tvar colNames = _representation.inObjects[0].spec.colNames;\n\t\t\tvar colTypes = _representation.inObjects[0].spec.colTypes;\n\t\t\tvar numberColumns = [];\n\t\t\tfor (var i = 0; i < colNames.length; i++) {\n\t\t\t\tif (colTypes[i] == \"number\") {\n\t\t\t\t\tnumberColumns.push(colNames[i]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n    \t\tvar colSelect = knimeService.createMenuSelect('columnSelect', _value.options.freq, numberColumns, function() {\n    \t\t\t_value.options.freq = this.value;\n\t\t\t\tupdateData(true);\n    \t\t});\n    \t\tknimeService.addMenuItem('Column:', 'minus-square fa-rotate-90', colSelect);\n    \t\t\n    \t\tif (labelEdit || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n        }*/\n\t    \n\t    if (labelEdit) {\n\t    \tvar labelCbx = knimeService.createMenuCheckbox('labelCbx', _value.options.showLabels, function () {\n\t    \t\tif (_value.options.showLabels != this.checked) {\n\t\t\t\t\t_value.options.showLabels = this.checked;\n\t\t\t\t\tchart.showLabels(this.checked);\n\t\t\t\t\td3.selectAll(\"#labelType input\").property(\"disabled\", !_value.options.showLabels);\n\t\t\t\t\t//workaround for nvd3 bug, remove labels manually\n\t\t\t\t\tif (!this.checked) {\n\t\t\t\t\t\td3.selectAll(\".nv-pieLabels *\").remove();\n\t\t\t\t\t}\n\t\t\t\t\tchart.update();\n\t\t\t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem('Show labels:', 'comment-o', labelCbx);\n\t    \t\n\t    \tvar labelTypeRadio = knimeService.createInlineMenuRadioButtons('labelType', 'labelType', 'Value', ['Key', 'Value', 'Percent'], function() {\n\t    \t\t_value.options.labelType = this.value;\n\t\t\t\tchart.labelType(this.value.toLowerCase());\n\t\t\t\tchart.update();\n\t    \t});\n\t    \tknimeService.addMenuItem('Label type:', 'commenting-o', labelTypeRadio);\n\t    \t\n\t\t    if (switchMissValCat || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (switchMissValCat && missValCatValue !== undefined && _representation.options.reportOnMissingValues) {\n\t    \tvar switchMissValCatCbx = knimeService.createMenuCheckbox('switchMissValCatCbx', _value.options.includeMissValCat, function() {\n\t    \t\tif (_value.options.includeMissValCat != this.checked) {\n\t    \t\t\t_value.options.includeMissValCat = this.checked;\n\t    \t\t\tprocessMissingValues(true);\n\t    \t\t\tchart.update();\n\t    \t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem(\"Include 'Missing values' category: \", 'question', switchMissValCatCbx);\n\t    \t\n\t    \tif (donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \tif (donutToggle) {\n\t\t    \tvar donutCbx = knimeService.createMenuCheckbox('donutCbx', _value.options.togglePie, function () {\n\t\t    \t\tif (_value.options.togglePie != this.checked) {\n\t\t\t\t\t\t_value.options.togglePie = this.checked;\n\t\t\t\t\t\tchart.donut(this.checked);\n\t\t\t\t\t\td3.selectAll(\"#insideTitleText, #holeRatioText\").property(\"disabled\", !_value.options.togglePie);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t\t    \t});\n\t\t    \tknimeService.addMenuItem('Render donut chart:', knimeService.createStackedIcon('gear', 'circle-o'), donutCbx);\n\t    \t}\n\t    \t\n\t    \tif (holeEdit) {\n\t    \t\tvar holeRatioText = knimeService.createMenuTextField('holeRatioText', _value.options.holeSize, function() {\n\t    \t\t\tif (this.value < 0) {\n    \t\t\t\t\tthis.value = 0;\n    \t\t\t\t} else if (this.value > 1) {\n    \t\t\t\t\tthis.value = 1;\n    \t\t\t\t}\n    \t\t\t\tchart.donutRatio(this.value);\n    \t\t\t\tchart.update();\n\t    \t\t}, true);\n\t    \t\tholeRatioText.setAttribute(\"type\", \"number\");\n\t    \t\tholeRatioText.setAttribute(\"min\", 0);\n\t    \t\tholeRatioText.setAttribute(\"max\", 1);\n\t    \t\tholeRatioText.setAttribute(\"step\", 0.1);\n\t    \t\tholeRatioText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Donut hole ratio:', 'adjust', holeRatioText);\n\t    \t}\n\t    \t\n\t    \t/*if (insideTitleEdit) {\n\t    \t\tvar insideTitleText = knimeService.createMenuTextField('insideTitleText', _value.options.insideTitle, function() {\n\t    \t\t\tif (_value.options.insideTitle != this.value) {\n\t\t\t\t\t\t_value.options.insideTitle = this.value;\n\t\t\t\t\t\tchart.title(this.value);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tinsideTitleText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Title inside:', 'header', insideTitleText, null, knimeService.SMALL_ICON);\n\t    \t}*/\n\t    \t\n\t        if (enableSelection) {\n\t        \tknimeService.addMenuDivider();\n\t        \tvar subscribeToSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-double-right', 'faded right sm', 'left bold');\n\t        \tvar subscribeToSelectionMenu = knimeService.createMenuCheckbox('subscribeToSelection', \n\t        \t\t\t_value.options.subscribeToSelection, function () {\n\t        \t\tif (_value.options.subscribeToSelection != this.checked) {\n\t        \t\t\t_value.options.subscribeToSelection = this.checked;\n\t        \t\t\tsubscribeToSelection(_value.options.subscribeToSelection);\n\t        \t\t}\n\t        \t});\n\t        \tknimeService.addMenuItem('Subscribe to selection:', subscribeToSelectionIcon, subscribeToSelectionMenu);\n\t        \t\n\t        \tvar publishSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-right', 'faded left sm', 'right bold');\n\t            var publishSelectionMenu = knimeService.createMenuCheckbox('publishSelection', _value.options.publishSelection,\n\t                function () {\n\t                    if (_value.options.publishSelection != this.checked) {\n\t                        _value.options.publishSelection = this.checked;\n\t                        publishSelection(this.checked);\n\t                    }\n\t                });\n\t            knimeService.addMenuItem('Publish selection:', publishSelectionIcon, publishSelectionMenu);\n\t        }\n\t        \n\t        if (displayClearButton &&  _representation.options.enableSelection) {\n\t\t\t\tknimeService.addButton(\"clearSelectionButton\", \"minus-square-o\", \"Clear selection\", function(){\n\t\t\t\t\td3.selectAll(\".row\").classed({\"selected\": false, \"knime-selected\": false, \"unselected\": false });\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t\t_value.options['selection'] = [];\n\t\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t\td3.select(\"#clearSelectionButton\").classed(\"inactive\", true);\n\t\t\t}\n    \t}\n\t};\n\n\tfunction setCssClasses() {\t\t\n\t\td3.selectAll('.nv-label')\n\t\t\t.classed('knime-label', true);\n\n\t\t// legend\n\t\td3.selectAll('.nv-legendWrap')\n\t\t\t.classed('knime-legend', true);\n\t\td3.selectAll('.nv-legend-symbol')\n\t\t\t.classed('knime-legend-symbol', true);\n\t\td3.selectAll('.nv-legend-text')\n\t\t\t.classed('knime-legend-label', true);\n\t\tif(_representation.options['enableSelection']) {\n\t\t\tregisterClickHandler();\n\t\t}\n\t}\n\t\n\tfunction setTooltipCssClasses() {\n\t\t// tooltip\n\t\tvar tooltip = d3.selectAll('.nvtooltip')\n\t\t.classed('knime-tooltip', true);\n\t\ttooltip.selectAll('.x-value')\n\t\t.classed('knime-tooltip-caption', true)\n\t\t.classed('knime-x', true);\n\t\ttooltip.selectAll('.legend-color-guide')\n\t\t.classed('knime-tooltip-color', true);\n\t\ttooltip.selectAll('.key')\n\t\t.classed('knime-tooltip-key', true);\n\t\ttooltip.selectAll('.value')\n\t\t.classed('knime-tooltip-value', true);\n\t}\n\n\tpie.validate = function() {\n\t\treturn true;\n\t}\n\n\tpie.getComponentValue = function() {\n\t\treturn _value;\n\t}\n\n\tpie.getSVG = function() {\t\t\n\t\t// correct faulty rect elements\n\t\td3.selectAll(\"rect\").each(function() {\n\t\t\tvar rect = d3.select(this);\n\t\t\tif (!rect.attr(\"width\")) {\n\t\t\t\trect.attr(\"width\", 0);\n\t\t\t}\n\t\t\tif (!rect.attr(\"height\")) {\n\t\t\t\trect.attr(\"height\", 0);\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar svgElement = d3.select(\"svg\")[0][0];\n\t\tknimeService.inlineSvgStyles(svgElement);\n\n\t\t// Return the SVG as a string.\n\t\treturn (new XMLSerializer()).serializeToString(svgElement);\n\t}\n\n\treturn pie;\n\n}());"],"cssCode":["text.knime-tick-label.knime-selected {\n\tfont-weight: bold;\n}\npath.knime-selected {\n\tfill: orange;\n\t\n}\npath.knime-partially-selected {\n\tfill: grey;\n}\ntext.knime-tick-label.knime-partially-selected {\n\tfont-weight: bold;\n}\n\npath.nv-bar.positive {\n\tcursor:pointer;\n}"],"flowVariables":{"knime.workspace":"C:\\Users\\mehar\\knime-workspace","css-stylesheet":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-size: 12px; \n}\n"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Pie/Donut Chart (JavaScript)"}},"58:0:36":{"@class":"org.knime.js.core.JSONWebNode","namespace":"dynamicJSNode","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/requireJS/2.1.8/require.js","/js-lib/knime/knime_table_1_0_0.js","/org/knime/dynamic/js/dynamicJSNode.js"],"getViewValueMethodName":"getComponentValue","customCSS":"","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css"],"viewValue":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewValue","options":{"includeMissValCat":true,"togglePie":false,"insideTitle":"","showLabels":true,"subtitle":"Inactive Policyholders","freq":"Selected (JavaScript Table View)","labelType":"Percent","title":"State-wise Breakdown ","subscribeToSelection":true,"publishSelection":true,"holeSize":0.35},"tables":{},"outColumns":{},"flowVariables":{}},"viewRepresentation":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewRepresentation","runningInView":true,"options":{"displayFullscreenButton":true,"displayClearSelectionButton":true,"enableHoleEdit":true,"svg":{"width":600,"height":400,"fullscreen":false},"legend":true,"enableInsideTitleEdit":true,"customColors":false,"enableTitleEdit":true,"enableSelection":true,"enableDonutToggle":true,"enableLabelEdit":true,"enableSwitchMissValCat":true,"processInMemory":true,"reportOnMissingValues":true,"labelThreshold":0.05,"cat":"State","enableViewControls":true,"enableColumnChooser":true,"showWarnings":true,"enableSubtitleEdit":true,"aggr":"OccurenceÂ Count"},"cssDependencies":["js-lib/nvd3/nv.d3.v1_8_1.min.css"],"jsDependencies":[{"name":"nvd3","path":"js-lib/nvd3/nv.d3.v1_8_1.min.js","dependencies":["D3_3.5.5"],"local":true,"usesDefine":false,"exports":"nv"},{"name":"D3_3.5.5","path":"js-lib/d3/d3.v3_5_5.min.js","dependencies":[],"local":true,"usesDefine":false,"exports":null}],"errorMessage":"","binaryFiles":{},"inObjects":[{"table":{"@class":"org.knime.js.core.JSONDataTable","id":"26b809f4-0fdd-42ec-be4c-773fa04f248f","extensions":null,"rows":[{"data":["VIC",13.0],"rowKey":"Row0"},{"data":["SA",3.0],"rowKey":"Row1"},{"data":["QLD",12.0],"rowKey":"Row2"},{"data":["NSW",11.0],"rowKey":"Row3"},{"data":["TAS",1.0],"rowKey":"Row4"},{"data":["NT",2.0],"rowKey":"Row5"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":2,"possibleValues":[["VIC","SA","QLD","NSW","TAS","NT"],null],"containsMissingValues":[false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":6,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null],"maxValues":["VIC",13.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":["NSW",1.0],"colNames":["State","State_1"],"knimeTypes":["String","Number (integer)"],"colTypes":["string","number"],"colorModels":[],"numExtensions":0}},"uuid":"01fd3702-b27d-4266-adda-c4face54ff85","translator":{"mapping":{"Row0":["Row41","Row527","Row82","Row949","Row253","Row583","Row199","Row287","Row168","Row821","Row745","Row943","Row405"],"Row1":["Row51","Row71","Row297"],"Row4":["Row523"],"Row5":["Row605","Row690"],"Row2":["Row385","Row354","Row179","Row740","Row268","Row389","Row401","Row698","Row139","Row216","Row557","Row217"],"Row3":["Row219","Row380","Row198","Row441","Row279","Row950","Row676","Row753","Row962","Row314","Row886"]},"sourceID":null,"targetIDs":null,"forward":false}}],"jsNamespace":"pie_chart_namespace","warnMessage":"","tableIds":["a2402966-a263-4220-9113-85a682cc8244"],"jsCode":["(pie_chart_namespace = function() {\n\n\tvar pie = {};\n\tvar _representation, _value;\n\tvar layoutContainer;\n\tvar MIN_HEIGHT = 100, MIN_WIDTH = 100;\n\tvar chart, svg;\n\tvar knimeTable;\n\t\n\tvar plotData;\n\tvar colorRange;\n\tvar excludeCat;\n\tvar missValCatValue;\n    var _translator;\n    var _keyNameMap;\n    var _incomingTable;\n\t\n\tvar showWarnings;\n\t\n\tvar MISSING_VALUES_ONLY = \"missingValuesOnly\";\n\tvar NO_DATA_AVAILABLE = \"noDataAvailable\";\n\n\tpie.init = function(representation, value) {\n\t\t_representation = representation;\n\t\t_value = value;\n\t\t_incomingTable = _representation.inObjects[0].table;\n\t\t\n\t\tif(_representation.options.enableSelection && _representation.inObjects[0].translator) {\n        \t_translator = _representation.inObjects[0].translator;\n        \t_translator.sourceID = _representation.inObjects[0].uuid;\n        \t_translator.targetIDs = [_representation.tableIds[0]];\n        \tknimeService.registerSelectionTranslator(_translator, _translator.sourceID);\n        \tsubscribeToSelection(_value.options.subscribeToSelection);\n        }\n\t\t\n\t\tshowWarnings = _representation.options.showWarnings;\n\t\t\n\t\tif (_representation.warnMessage && showWarnings) {\n\t\t\tknimeService.setWarningMessage(_representation.warnMessage);\n\t\t}\n\n\t\tdrawChart(false);\n\t\tif (_representation.options.enableViewControls) {\n\t\t\tdrawControls();\n\t\t}\n\t\t_keyNameMap = new KeyNameMap(getClusterToRowMapping());\n\t}\n\n\tfunction drawChart(redraw) {\t\t\n\t\t// Parse the options\n\t\tvar optTitle = _value.options[\"title\"];\n\t\tvar optSubtitle = _value.options[\"subtitle\"];\n\n\t\tvar showLabels = _value.options[\"showLabels\"];\n\t\tvar labelThreshold = _representation.options[\"labelThreshold\"];\n\t\tvar labelType = _value.options[\"labelType\"].toLowerCase();\n\t\t\t\t\n\t\tvar optDonutChart = _value.options[\"togglePie\"];\n\t\tvar holeSize = _value.options[\"holeSize\"];\n\t\tvar optInsideTitle = _value.options[\"insideTitle\"];\n\n\t\tvar showLegend = _representation.options[\"legend\"];\n\n\t\tvar optFullscreen = _representation.options[\"svg\"][\"fullscreen\"] && _representation.runningInView;\n\t\tvar optWidth = _representation.options[\"svg\"][\"width\"]\n\t\tvar optHeight = _representation.options[\"svg\"][\"height\"]\n\t\t\n\t\tvar optEnableSelection = _representation.options['enableSelection'];\n\t\t\n\t\tvar isTitle = optTitle || optSubtitle;\n\n\t\t/*\n\t\t * Setup interactive controls\n\t\t */\n\t\t\n\t\td3.select(\"html\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n        d3.select(\"body\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n\n\t\tvar body = d3.select(\"body\");\n\n\t\tvar width = optWidth + \"px\";\n\t\tvar height = optHeight + \"px\";\n\t\tif (optFullscreen) {\n\t\t\twidth = \"100%\";\n\t\t\theight = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t}\n\t\t\n\t\tvar div;\n\t\tif (redraw) {\n\t\t\td3.select(\"svg\").remove();\n\t\t\tdiv = d3.select(\"#svgContainer\");\n\t\t} else {\n\t\t\tlayoutContainer = body.append(\"div\")\n\t\t\t\t.attr(\"id\", \"layoutContainer\")\n\t\t\t\t.attr('class', 'knime-layout-container')\t\t\t\t\n\t\t\t\t.style(\"width\", width)\n\t\t\t\t.style(\"height\", height)\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\t\t\n\t\t\t\n\t\t\tdiv = layoutContainer.append(\"div\")\n\t\t\t\t.attr(\"id\", \"svgContainer\")\n\t\t\t\t.attr('class', 'knime-svg-container')\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\n\t\t}\n\n\t\t/*\n\t\t * Process data\n\t\t */\n\t\tknimeTable = new kt();\n\t\t// Add the data from the input port to the knimeTable.\n\t\tvar port0dataTable = _representation.inObjects[0].table;\n\t\tport0dataTable.rows = sortByClusterName(port0dataTable.rows);\n\t\tknimeTable.setDataTable(port0dataTable);\n\t\t\n\t\tprocessData(true);\t\n\t\tsetColorRange();\n\t\t\n\t\t// Create the SVG object\n\t\tvar svg1 = document\n\t\t\t\t.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tdiv[0][0].appendChild(svg1);\n\n\t\tsvg = d3.select(\"svg\")\n\t\t\t.style(\"display\", \"block\");\n\n\t\tif (!optFullscreen) {\n\t\t\tif (optWidth > 0) {\n\t\t\t\tdiv.style(\"width\", optWidth + \"px\")\n\t\t\t\tsvg.attr(\"width\", optWidth);\n\t\t\t}\n\t\t\tif (optHeight > 0) {\n\t\t\t\tsvg.attr(\"height\", optHeight);\n\t\t\t\tdiv.style(\"height\", optHeight + \"px\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Set full screen height/width\n\t\t\tdiv.style(\"width\", \"100%\");\n\t\t\tdiv.style(\"height\", height);\n\n\t\t\tsvg.attr(\"width\", \"100%\");\n\t\t\tsvg.attr(\"height\", \"100%\");\n\t\t}\n\t\n\t\t// Pie chart\n\t\tnv.addGraph(function() {\n\t\t\tchart = nv.models.pieChart()\n\t\t\t\t.x(function(d) { return d.label })\n\t\t\t\t.y(function(d) { return d.value })\n\t\t\t\t.color(colorRange)\n\t\t\t\t.duration(0)\n\t\t\t\t.showLegend(showLegend)\n\t\t\t\t.showLabels(showLabels)\n\t\t\t\t.labelThreshold(labelThreshold) \n\t\t\t\t.labelType(labelType); // \"key\", \"value\" or \"percent\"\n\n\t\t\tchart.dispatch.on('renderEnd.css', function() {\n\t\t\t\tsetCssClasses();\n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t// tooltip is re-created every time therefore we need to assign classes accordingly\n\t\t\tchart.pie.dispatch.on('elementMouseover.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.pie.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.legend.dispatch.on('legendClick', function(series, index) {\n            \t//drawChart(true);\n            \tremoveHilightBar(\"\",true);\n            \td3.event.stopPropagation();\n            });\n\t\t\t\n\t\t\tchart.width(optFullscreen ? \"100%\" : optWidth);\n\t\t\tchart.height(optFullscreen ? \"100%\" : optHeight);\n\t\t\tchart.margin({top: 0, bottom: 0, left: 20, right: 0});\n\n\t\t\t// TODO: Add a mechanism to remember the categories that are\n\t\t\t// switched on.\n\n\t\t\tchart.donut(optDonutChart);\n\t\t\tchart.donutRatio(holeSize);\n\t\t\tif (optInsideTitle) {\n\t\t\t\tchart.title(optInsideTitle);\n\t\t\t}\n\t\t\tupdateTitles(false);\n\n\t\t\t// checking if all the pies are 0s\n\t\t\tif (plotData.filter(function(d) { return d.value !== 0 }).length === 0) {\n\t\t\t\tsvg.append('text')\n\t\t\t\t\t.attr('x', 20)\n\t\t\t\t\t.attr('y', 80)\n\t\t\t\t\t.attr('font-size', 20)\n\t\t\t\t\t.attr('fill', 'red')\n\t\t\t\t\t.text('The plot is empty because all values are equal to 0.');\n\t\t\t} else {\n\t\t\t\tsvg.datum(plotData).transition().duration(0).call(chart);\n\t\t\t}\n\t\t\t//nv.utils.windowResize(chart.update);\n\t\t\tnv.utils.windowResize(function () { \n\t\t\t\tchart.update(); \n\t\t\t\tremoveHilightBar(\"\",true); \n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t\n\t\t\tif(optEnableSelection) {\n\t\t\t\tsvg.on(\"click\", function() {\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t_value.options['selection'] = [];\n\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// redraws selection\n            redrawSelection();\n\n\t\t\treturn chart;\n\t\t});\n\t}\n\t\n    function sortByClusterName(array) {\n        return array.sort(function(a, b) {\n            var x = a.data[0];\n            var y = b.data[0];\n            \n            // Make sure, that missing values are displayed last\n            if(x == null) {\n            \treturn 1\n            } else if (y == null) {\n            \treturn -1;\n            }\n            \n            if (typeof x == \"string\")\n            {\n                x = (\"\"+x).toLowerCase(); \n            }\n            if (typeof y == \"string\")\n            {\n                y = (\"\"+y).toLowerCase();\n            }\n            return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n        });\n    }\n\t\n    function registerClickHandler () {\n        d3.selectAll(\".nv-slice\").on('click',function(event) {\n            handleHighlightClick(event);\n            d3.event.stopPropagation();\n        });\n    }\n\n    function redrawSelection() {\n        var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n        for (var i = 0; i < length; i++) {\n            createHilightBar(_keyNameMap.getNameFromKey(_value.options['selection'][i][0]), \n                _value.options['selection'][i][1]);\n        }\n    }\n\n    function subscribeToSelection(subscribeBool) {\n        if(_representation.options.enableSelection) {\n            if(subscribeBool) {\n                knimeService.subscribeToSelection(_translator.sourceID, onSelectionChanged);\n            } else {\n                knimeService.unsubscribeSelection(_translator.sourceID, onSelectionChanged);\n            }\n        }\n    }\n\n    function publishSelection(shouldPublish){\n        if(shouldPublish) {\n            knimeService.setSelectedRows(_translator.sourceID, getSelectedRowIDs(), _translator.sourceID);\n        }\n    }\n\n    function checkClearSelectionButton(){\n        var button = d3.select(\"#clearSelectionButton\");\n        if (button){\n            button.classed(\"inactive\", function(){return !_value.options['selection'].length > 0});\n        }\n    }\n\n    function getSelectedRowIDs() {\n        if(_value.options['selection']) {\n            var selectedRowIDs = [];\n            for (var i = 0; i< _value.options['selection'].length; i++) {\n                selectedRowIDs.push( _value.options['selection'][i][0]);\n            }\n            return selectedRowIDs;\n        } else {\n            return [];\n        }\n    }\n\n    // Removes the clusterName with the given cluster name. If \"removeAll\" is true all bars are removed\n    function removeHilightBar(clusterName, removeAll) {\n        if (removeAll) {\n            var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n            for (var i = 0; i < length; i++) {\n                d3.selectAll(\".hilightBar\").remove();\n            }\n        } else {\n            var barIndex = getSelectedRowIDs().indexOf(_keyNameMap.getKeyFromName(clusterName));\n            if(barIndex > -1) {\n                let pie = selectCorrectBar(clusterName);\n                if (pie){\n                    pie.remove();\n                }\n            }\n        }\n    } \n\n    function selectCorrectBar(clusterName) {\n        let allSlices = d3.selectAll(\".nv-slice\");\n        for(var j = 0; j < allSlices[0].length; j++) {\n            if(d3.select(allSlices[0][j]).data()[0].data.label == clusterName) {\n                return d3.select(allSlices[0][j]).select(\".hilightBar\");\n            }\n        }\n    }\n\n    // Create a hilight-bar above the cluster with the given name and assigns the given css class to it\n    function createHilightBar (clusterName, selectionClass) {\n        for(var j = 0; j < plotData.length; j++) {\n            if(plotData[j].label === clusterName) {\n                var slices = d3.selectAll(\".nv-slice\");\n                for(var i = 0; i < slices[0].length; i++) {\n                    if(i==j) {\n                        var slice = d3.select(slices[0][i]).select(\"path\");\n                        var availableWidth = chart.width() - 20;\n                        var availableHeight = chart.height();\n                        var radius = Math.min(availableWidth, availableHeight) / 2;\n                        var selectionTitle;\n                        if(selectionClass == \"knime-selected\") {\n                            selectionTitle = \"Selected\";\n                        } else {\n                            selectionTitle = \"Partially selected\";\n                        }\n                        //PieChart Code\n                        var arc = d3.svg.arc()\n                        .innerRadius((radius - radius / 5))\n                        .outerRadius((radius - radius / 5)+8)\n                        .startAngle(slice.data()[0].startAngle) //converting from degs to radians\n                        .endAngle(slice.data()[0].endAngle); //just radians\n\n                        slice.select(function() { return this.parentNode; }).append(\"path\")\n                        .attr(\"d\", arc)\n                        .classed(\"hilightBar\",true)\n                        .classed(selectionClass, true)\n                        .append(\"title\")\n                        .classed('knime-tooltip', true)\n                        .text(selectionTitle);\n                    } \n                }\n            }\n        }\n    }\n\n    function getClusterToRowMapping() {\n        var map = {};\n        for (var i = 0; i < _incomingTable.rows.length; i++) {\n            if(_incomingTable.rows[i].data[0]) {\n                map[_incomingTable.rows[i].data[0]] = _incomingTable.rows[i].rowKey;\n            } else {\n                map[\"Missing values\"] = _incomingTable.rows[i].rowKey;\n            }\n        }\n        return map;\n    }\n\n    // Helper class to handle conversion from cluster name to row key\n    function KeyNameMap(map) {\n        this.map = map;\n        this.reverseMap = {};\n        for(var key in map){\n            var value = map[key];\n            this.reverseMap[value] = key;   \n        }\n    }\n\n    KeyNameMap.prototype.getKeyFromName = function(name){ \n        return this.map[name]; \n    }\n    KeyNameMap.prototype.getNameFromKey = function(key){\n        return this.reverseMap[key];\n    }\n\n    function handleHighlightClick(event) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        var clusterName = event.data.label;\n        var clusterKey = _keyNameMap.getKeyFromName(clusterName);\n        var barIndex = getSelectedRowIDs().indexOf(clusterKey);\n        // Deselect already selected bar when clicking again on it\n        if(barIndex > -1 && (d3.event.ctrlKey || d3.event.shiftKey || d3.event.metaKey)){\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.removeRowsFromSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, false);\n            _value.options['selection'].splice(barIndex, 1);\n        } else if(!d3.event.ctrlKey && !d3.event.shiftKey && !d3.event.metaKey) {\n            // Deselect all previously selected bars and select the newly clicked one\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.setSelectedRows(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, true);\n            _value.options['selection']= [];\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        } else {\n            // Select the clicked bar, as it is either a new selection or a additional selection\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.addRowsToSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        }\n        checkClearSelectionButton();\n    }\n\n    function onSelectionChanged(data) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        if (data.reevaluate) {\n            removeHilightBar(\"\", true);\n            var selectedRows = knimeService.getAllRowsForSelection(_translator.sourceID);\n            var partiallySelectedRows = knimeService.getAllPartiallySelectedRows(_translator.sourceID);\n            _value.options['selection'] = [];\n            for (let selectedRow in selectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [selectedRows[selectedRow], \"knime-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(selectedRows[selectedRow]),\n                \"knime-selected\");\n            }\n            for (let partiallySelectedRow in partiallySelectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [partiallySelectedRows[partiallySelectedRow], \"knime-partially-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(partiallySelectedRows[partiallySelectedRow]),\n                \"knime-partially-selected\");\n            }\n        } else if (data.changeSet) {\n            if (data.changeSet.removed) {\n                data.changeSet.removed.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if(data.changeSet.partialRemoved) {\n                data.changeSet.partialRemoved.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if (data.changeSet.added) {\n                data.changeSet.added.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-selected\");\n                    }\n                });\n            }\n            if(data.changeSet.partialAdded) {\n                data.changeSet.partialAdded.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-partially-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-partially-selected\");\n                    }\n                });\n            }\n        }\n        checkClearSelectionButton();\n    }\n\n\t\n\tfunction updateData(updateChart) {\n\t\tprocessData();\n\t\tif (updateChart) {\n\t\t\tchart.update();\n\t\t}\n\t}\n\t\n\tfunction updateTitles(updateChart) {\n\t\tif (chart) {\n\t\t\tvar curTitle = d3.select(\"#title\");\n\t\t\tvar curSubtitle = d3.select(\"#subtitle\");\n\t\t\tvar chartNeedsUpdating = curTitle.empty() != !(_value.options.title) \n\t\t\t\t|| curSubtitle.empty() != !(_value.options.subtitle);\n\t\t\tif (!_value.options.title) {\n\t\t\t\tcurTitle.remove();\n\t\t\t}\n\t\t\tif (_value.options.title) {\n\t\t\t\tif (curTitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", 30)\n\t\t\t\t\t\t.attr(\"id\", \"title\")\n\t\t\t\t\t\t.attr('class', 'knime-title')\n\t\t\t\t\t\t.text(_value.options.title);\n\t\t\t\t} else {\n\t\t\t\t\tcurTitle.text(_value.options.title);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_value.options.subtitle) {\n\t\t\t\tcurSubtitle.remove();\n\t\t\t} \n\t\t\tif (_value.options.subtitle) {\n\t\t\t\tif (curSubtitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20)\n\t\t\t\t\t\t.attr(\"id\", \"subtitle\")\n\t\t\t\t\t\t.attr('class', 'knime-subtitle')\n\t\t\t\t\t\t.text(_value.options.subtitle);\n\t\t\t\t} else {\n\t\t\t\t\tcurSubtitle.text(_value.options.subtitle)\n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar topMargin = 10;\n\t\t\ttopMargin += _value.options.title ? 10 : 0;\n\t\t\ttopMargin += _value.options.subtitle ? 8 : 0;\n\t\t\tchart.legend.margin({top: topMargin, bottom: topMargin});\n\t\t\tchart.margin({top: topMargin, bottom: topMargin});\n\t\t\t\n\t\t\tvar isTitle = _value.options.title || _value.options.subtitle;\n\t\t\tknimeService.floatingHeader(isTitle);\t\t\t\n\t\t\n\t\t\t\n\t\t\tif (updateChart && chartNeedsUpdating) {\n\t\t\t\tif (_representation.options.svg.fullscreen && _representation.runningInView ) {\n\t\t\t\t\tvar height = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t\t\t\tlayoutContainer.style(\"height\", height)\n\t\t\t\t\t\t// two rows below force to invalidate the container which solves a weird problem with vertical scroll bar in IE\n\t\t\t\t\t\t.style('display', 'none')\n\t\t\t\t\t\t.style('display', 'block');\n\t\t\t\t\td3.select(\"#svgContainer\").style(\"height\", height); \n\t\t\t\t}\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprocessData = function(setColorRange) {\n\t\tvar optMethod = _representation.options[\"aggr\"];\n\t\tvar optCat = _representation.options[\"cat\"];\n\t\tvar optFreqCol = _value.options[\"freq\"];\n\t\t\n\t\tvar categories = knimeTable.getColumn(optCat);\n\t\t\n\t\tvar valCol;\n\t\tif (optMethod == \"Occurence\\u00A0Count\") {\n\t\t\tvalCol = knimeTable.getColumn(1);\n\t\t} else {\n\t\t\tvalCol = knimeTable.getColumn(optFreqCol);\n\t\t}\n\t\t\n\t\tplotData = [];\n\t\texcludeCat = [];\n\t\tmissValCatValue = undefined;\n\t\tif (valCol.length > 0) {\n\t\t\tvar numDataPoints = valCol.length;\n\t\t\tfor (var i = 0; i < numDataPoints; i++) {\n\t\t\t\tvar label = categories[i];\n\t\t\t\tvar value = valCol[i];\n\t\t\t\t\n\t\t\t\tif (label === null) {\n\t\t\t\t\t// missing values category\t\t\t\t\t\n\t\t\t\t\t// save the value to append as the last item\t\t\t\t\t\t\n\t\t\t\t\tmissValCatValue = value;\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value === null) {\n\t\t\t\t\t// category has only missing values - exclude it\n\t\t\t\t\texcludeCat.push(label);\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar plotStream = {\n\t\t\t\t\t\"label\" : label,\n\t\t\t\t\t\"value\" : Math.abs(value)  // take abs value to prevent a damaged plot\n\t\t\t\t};\t\t\t\t\n\t\t\t\tplotData.push(plotStream);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprocessMissingValues(false);\n\t}\n\t\n\tsetColorRange = function() {\n\t\tvar numCat = plotData.length;\n\t\tif (missValCatValue !== undefined && missValCatValue !== null) {\n\t\t\t// We don't want the option \"includeMissValCat\" to influence on the number of categories,\n\t\t\t// because the option can be changed in the view and the color scale then can also be changed (if a border case) - and we don't want this.\n\t\t\t// Hence, only the real value matters.\n\t\t\tnumCat++;\n\t\t}\n\t\tif (_representation.options.customColors) {\n\t\t\tcolorRange = [];\n\t\t\tfor (var i = 0; i < numCat; i++) {\n\t\t\t\tvar color = knimeTable.getRowColors()[i];\n\t\t\t\tif (!color) {\n\t\t\t\t\tcolor = \"#7C7C7C\";\n\t\t\t\t}\n\t\t\t\tcolorRange.push(color);\n\t\t\t}\n\t\t} else {\n\t\t\tvar colorScale;\n\t\t\tif (numCat > 10) {\n\t\t\t\tcolorScale = d3.scale.category20();\n\t\t\t} else {\n\t\t\t\tcolorScale = d3.scale.category10();\n\t\t\t}\n\t\t\tcolorRange = colorScale.range();\n\t\t}\n\t}\n\t\n\t/**\n\t * switched - if the chart update was triggered by changing the \"include 'Missing values' category\" option in the view\n\t */\n\tprocessMissingValues = function(switched) {\n\t\t// Missing values post-processing\t\n\t\tif (missValCatValue !== undefined) {  // undefined means there's no missing value in the category column at all\n\t\t\tif (_value.options.includeMissValCat && _representation.options.reportOnMissingValues) {\n\t\t\t\t// add missing values category\n\t\t\t\tvar label = \"Missing values\";\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.push({\"label\": label, \"value\": missValCatValue});\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.push(label);\n\t\t\t\t}\n\t\t\t} else if (switched) {\n\t\t\t\t// remove missing values category, but only if we have triggered switch from the view\n\t\t\t\t// otherwise there's nothing to remove yet\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.pop();\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set warning messages\n\t\tif (!showWarnings) {\n\t\t\treturn;\n\t\t}\n\t\tif (plotData.length == 0) {\n\t\t\t// No data available warnings\n\t\t\tvar str;\n\t\t\tif (missValCatValue !== undefined && missValCatValue !== null && _representation.options.reportOnMissingValues) {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values.\\nThere are values where the category name is missing.\\nTo see them switch on the option \\\"Include 'Missing values' category\\\" in the view settings.\";\n\t\t\t} else {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values or empty.\\nRe-run the workflow with different data.\";\n\t\t\t}\n\t\t\tknimeService.setWarningMessage(str, NO_DATA_AVAILABLE);\n\t\t} else if (excludeCat.length > 0 && _representation.options.reportOnMissingValues) {\n\t\t\tknimeService.setWarningMessage(\"Categories '\" + excludeCat.join(\"', '\") + \"' have only missing values in the frequency column and were excluded from the view.\", MISSING_VALUES_ONLY)\n\t\t} else {\n\t\t\tknimeService.clearWarningMessage(MISSING_VALUES_ONLY);\n\t\t}\t\n\t}\n\t\t\n\tdrawControls = function() {\t\t\n\t\tif (!knimeService) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (_representation.options.displayFullscreenButton) {\n\t\t\tknimeService.allowFullscreen();\n\t\t}\n\t\t\n\t    if (!_representation.options.enableViewControls) return;\n\t    \n\t    var titleEdit = _representation.options.enableTitleEdit;\n\t\tvar subtitleEdit = _representation.options.enableSubtitleEdit;\n\t\tvar donutToggle = _representation.options.enableDonutToggle;\n\t\tvar holeEdit = _representation.options.enableHoleEdit;\n\t\t//var insideTitleEdit = _representation.options.enableInsideTitleEdit;\n\t\t//var colChooser = _representation.options.enableColumnChooser;\n\t\tvar labelEdit = _representation.options.enableLabelEdit;\n\t\tvar switchMissValCat = _representation.options.enableSwitchMissValCat;\n\t\tvar enableSelection = _representation.options.enableSelection;\n\t\tvar displayClearButton = _representation.options.displayClearSelectionButton;\n\t    \n\t    if (titleEdit || subtitleEdit) {\t    \t    \n\t    \tif (titleEdit) {\n\t    \t\tvar chartTitleText = knimeService.createMenuTextField('chartTitleText', _value.options.title, function() {\n\t    \t\t\tif (_value.options.title != this.value) {\n\t\t\t\t\t\t_value.options.title = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tknimeService.addMenuItem('Chart Title:', 'header', chartTitleText);\n\t    \t}\n\t    \tif (subtitleEdit) {\n\t    \t\tvar chartSubtitleText = knimeService.createMenuTextField('chartSubtitleText', _value.options.subtitle, function() {\n\t    \t\t\tif (_value.options.subtitle != this.value) {\n\t\t\t\t\t\t_value.options.subtitle = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tvar mi = knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null, knimeService.SMALL_ICON);\n\t    \t}\t\n\t    \tif (/*colChooser ||*/ labelEdit || donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    /*if (colChooser) {\n\t    \t// filter out non number columns\n\t    \tvar colNames = _representation.inObjects[0].spec.colNames;\n\t\t\tvar colTypes = _representation.inObjects[0].spec.colTypes;\n\t\t\tvar numberColumns = [];\n\t\t\tfor (var i = 0; i < colNames.length; i++) {\n\t\t\t\tif (colTypes[i] == \"number\") {\n\t\t\t\t\tnumberColumns.push(colNames[i]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n    \t\tvar colSelect = knimeService.createMenuSelect('columnSelect', _value.options.freq, numberColumns, function() {\n    \t\t\t_value.options.freq = this.value;\n\t\t\t\tupdateData(true);\n    \t\t});\n    \t\tknimeService.addMenuItem('Column:', 'minus-square fa-rotate-90', colSelect);\n    \t\t\n    \t\tif (labelEdit || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n        }*/\n\t    \n\t    if (labelEdit) {\n\t    \tvar labelCbx = knimeService.createMenuCheckbox('labelCbx', _value.options.showLabels, function () {\n\t    \t\tif (_value.options.showLabels != this.checked) {\n\t\t\t\t\t_value.options.showLabels = this.checked;\n\t\t\t\t\tchart.showLabels(this.checked);\n\t\t\t\t\td3.selectAll(\"#labelType input\").property(\"disabled\", !_value.options.showLabels);\n\t\t\t\t\t//workaround for nvd3 bug, remove labels manually\n\t\t\t\t\tif (!this.checked) {\n\t\t\t\t\t\td3.selectAll(\".nv-pieLabels *\").remove();\n\t\t\t\t\t}\n\t\t\t\t\tchart.update();\n\t\t\t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem('Show labels:', 'comment-o', labelCbx);\n\t    \t\n\t    \tvar labelTypeRadio = knimeService.createInlineMenuRadioButtons('labelType', 'labelType', 'Value', ['Key', 'Value', 'Percent'], function() {\n\t    \t\t_value.options.labelType = this.value;\n\t\t\t\tchart.labelType(this.value.toLowerCase());\n\t\t\t\tchart.update();\n\t    \t});\n\t    \tknimeService.addMenuItem('Label type:', 'commenting-o', labelTypeRadio);\n\t    \t\n\t\t    if (switchMissValCat || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (switchMissValCat && missValCatValue !== undefined && _representation.options.reportOnMissingValues) {\n\t    \tvar switchMissValCatCbx = knimeService.createMenuCheckbox('switchMissValCatCbx', _value.options.includeMissValCat, function() {\n\t    \t\tif (_value.options.includeMissValCat != this.checked) {\n\t    \t\t\t_value.options.includeMissValCat = this.checked;\n\t    \t\t\tprocessMissingValues(true);\n\t    \t\t\tchart.update();\n\t    \t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem(\"Include 'Missing values' category: \", 'question', switchMissValCatCbx);\n\t    \t\n\t    \tif (donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \tif (donutToggle) {\n\t\t    \tvar donutCbx = knimeService.createMenuCheckbox('donutCbx', _value.options.togglePie, function () {\n\t\t    \t\tif (_value.options.togglePie != this.checked) {\n\t\t\t\t\t\t_value.options.togglePie = this.checked;\n\t\t\t\t\t\tchart.donut(this.checked);\n\t\t\t\t\t\td3.selectAll(\"#insideTitleText, #holeRatioText\").property(\"disabled\", !_value.options.togglePie);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t\t    \t});\n\t\t    \tknimeService.addMenuItem('Render donut chart:', knimeService.createStackedIcon('gear', 'circle-o'), donutCbx);\n\t    \t}\n\t    \t\n\t    \tif (holeEdit) {\n\t    \t\tvar holeRatioText = knimeService.createMenuTextField('holeRatioText', _value.options.holeSize, function() {\n\t    \t\t\tif (this.value < 0) {\n    \t\t\t\t\tthis.value = 0;\n    \t\t\t\t} else if (this.value > 1) {\n    \t\t\t\t\tthis.value = 1;\n    \t\t\t\t}\n    \t\t\t\tchart.donutRatio(this.value);\n    \t\t\t\tchart.update();\n\t    \t\t}, true);\n\t    \t\tholeRatioText.setAttribute(\"type\", \"number\");\n\t    \t\tholeRatioText.setAttribute(\"min\", 0);\n\t    \t\tholeRatioText.setAttribute(\"max\", 1);\n\t    \t\tholeRatioText.setAttribute(\"step\", 0.1);\n\t    \t\tholeRatioText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Donut hole ratio:', 'adjust', holeRatioText);\n\t    \t}\n\t    \t\n\t    \t/*if (insideTitleEdit) {\n\t    \t\tvar insideTitleText = knimeService.createMenuTextField('insideTitleText', _value.options.insideTitle, function() {\n\t    \t\t\tif (_value.options.insideTitle != this.value) {\n\t\t\t\t\t\t_value.options.insideTitle = this.value;\n\t\t\t\t\t\tchart.title(this.value);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tinsideTitleText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Title inside:', 'header', insideTitleText, null, knimeService.SMALL_ICON);\n\t    \t}*/\n\t    \t\n\t        if (enableSelection) {\n\t        \tknimeService.addMenuDivider();\n\t        \tvar subscribeToSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-double-right', 'faded right sm', 'left bold');\n\t        \tvar subscribeToSelectionMenu = knimeService.createMenuCheckbox('subscribeToSelection', \n\t        \t\t\t_value.options.subscribeToSelection, function () {\n\t        \t\tif (_value.options.subscribeToSelection != this.checked) {\n\t        \t\t\t_value.options.subscribeToSelection = this.checked;\n\t        \t\t\tsubscribeToSelection(_value.options.subscribeToSelection);\n\t        \t\t}\n\t        \t});\n\t        \tknimeService.addMenuItem('Subscribe to selection:', subscribeToSelectionIcon, subscribeToSelectionMenu);\n\t        \t\n\t        \tvar publishSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-right', 'faded left sm', 'right bold');\n\t            var publishSelectionMenu = knimeService.createMenuCheckbox('publishSelection', _value.options.publishSelection,\n\t                function () {\n\t                    if (_value.options.publishSelection != this.checked) {\n\t                        _value.options.publishSelection = this.checked;\n\t                        publishSelection(this.checked);\n\t                    }\n\t                });\n\t            knimeService.addMenuItem('Publish selection:', publishSelectionIcon, publishSelectionMenu);\n\t        }\n\t        \n\t        if (displayClearButton &&  _representation.options.enableSelection) {\n\t\t\t\tknimeService.addButton(\"clearSelectionButton\", \"minus-square-o\", \"Clear selection\", function(){\n\t\t\t\t\td3.selectAll(\".row\").classed({\"selected\": false, \"knime-selected\": false, \"unselected\": false });\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t\t_value.options['selection'] = [];\n\t\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t\td3.select(\"#clearSelectionButton\").classed(\"inactive\", true);\n\t\t\t}\n    \t}\n\t};\n\n\tfunction setCssClasses() {\t\t\n\t\td3.selectAll('.nv-label')\n\t\t\t.classed('knime-label', true);\n\n\t\t// legend\n\t\td3.selectAll('.nv-legendWrap')\n\t\t\t.classed('knime-legend', true);\n\t\td3.selectAll('.nv-legend-symbol')\n\t\t\t.classed('knime-legend-symbol', true);\n\t\td3.selectAll('.nv-legend-text')\n\t\t\t.classed('knime-legend-label', true);\n\t\tif(_representation.options['enableSelection']) {\n\t\t\tregisterClickHandler();\n\t\t}\n\t}\n\t\n\tfunction setTooltipCssClasses() {\n\t\t// tooltip\n\t\tvar tooltip = d3.selectAll('.nvtooltip')\n\t\t.classed('knime-tooltip', true);\n\t\ttooltip.selectAll('.x-value')\n\t\t.classed('knime-tooltip-caption', true)\n\t\t.classed('knime-x', true);\n\t\ttooltip.selectAll('.legend-color-guide')\n\t\t.classed('knime-tooltip-color', true);\n\t\ttooltip.selectAll('.key')\n\t\t.classed('knime-tooltip-key', true);\n\t\ttooltip.selectAll('.value')\n\t\t.classed('knime-tooltip-value', true);\n\t}\n\n\tpie.validate = function() {\n\t\treturn true;\n\t}\n\n\tpie.getComponentValue = function() {\n\t\treturn _value;\n\t}\n\n\tpie.getSVG = function() {\t\t\n\t\t// correct faulty rect elements\n\t\td3.selectAll(\"rect\").each(function() {\n\t\t\tvar rect = d3.select(this);\n\t\t\tif (!rect.attr(\"width\")) {\n\t\t\t\trect.attr(\"width\", 0);\n\t\t\t}\n\t\t\tif (!rect.attr(\"height\")) {\n\t\t\t\trect.attr(\"height\", 0);\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar svgElement = d3.select(\"svg\")[0][0];\n\t\tknimeService.inlineSvgStyles(svgElement);\n\n\t\t// Return the SVG as a string.\n\t\treturn (new XMLSerializer()).serializeToString(svgElement);\n\t}\n\n\treturn pie;\n\n}());"],"cssCode":["text.knime-tick-label.knime-selected {\n\tfont-weight: bold;\n}\npath.knime-selected {\n\tfill: orange;\n\t\n}\npath.knime-partially-selected {\n\tfill: grey;\n}\ntext.knime-tick-label.knime-partially-selected {\n\tfont-weight: bold;\n}\n\npath.nv-bar.positive {\n\tcursor:pointer;\n}"],"flowVariables":{"knime.workspace":"C:\\Users\\mehar\\knime-workspace","css-stylesheet":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\ttext-align: center;\n\tpadding-bottom: 8px;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-size: 12px; \n}\n\n.knime-label {\n\tcolor: white;\n}\n"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Pie/Donut Chart (JavaScript)"}},"58:0:47":{"@class":"org.knime.js.core.JSONWebNode","namespace":"dynamicJSNode","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/requireJS/2.1.8/require.js","/js-lib/knime/knime_table_1_0_0.js","/org/knime/dynamic/js/dynamicJSNode.js"],"getViewValueMethodName":"getComponentValue","customCSS":"","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css"],"viewValue":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewValue","options":{"includeMissValCat":true,"togglePie":false,"insideTitle":"","showLabels":true,"subtitle":"Monthly Benefiters Paying 0 Premium","freq":"Premium Install","labelType":"Percent","title":"Claim Type","subscribeToSelection":true,"publishSelection":true,"holeSize":0.35},"tables":{},"outColumns":{},"flowVariables":{}},"viewRepresentation":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewRepresentation","runningInView":true,"options":{"displayFullscreenButton":true,"displayClearSelectionButton":true,"enableHoleEdit":true,"svg":{"width":600,"height":400,"fullscreen":false},"legend":true,"enableInsideTitleEdit":true,"customColors":false,"enableTitleEdit":true,"enableSelection":true,"enableDonutToggle":true,"enableLabelEdit":true,"enableSwitchMissValCat":true,"processInMemory":true,"reportOnMissingValues":true,"labelThreshold":0.05,"cat":"ClaimType","enableViewControls":true,"enableColumnChooser":true,"showWarnings":true,"enableSubtitleEdit":true,"aggr":"OccurenceÂ Count"},"cssDependencies":["js-lib/nvd3/nv.d3.v1_8_1.min.css"],"jsDependencies":[{"name":"nvd3","path":"js-lib/nvd3/nv.d3.v1_8_1.min.js","dependencies":["D3_3.5.5"],"local":true,"usesDefine":false,"exports":"nv"},{"name":"D3_3.5.5","path":"js-lib/d3/d3.v3_5_5.min.js","dependencies":[],"local":true,"usesDefine":false,"exports":null}],"errorMessage":"","binaryFiles":{},"inObjects":[{"table":{"@class":"org.knime.js.core.JSONDataTable","id":"30ce25f3-9e09-427e-98ab-fc0ef635fff4","extensions":null,"rows":[{"data":["INP",58.0],"rowKey":"Row0"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":2,"possibleValues":[["INP"],null],"containsMissingValues":[false,false],"rowColorValues":["#404040"],"numRows":1,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null],"maxValues":["INP",58.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":["INP",58.0],"colNames":["ClaimType","ClaimType_1"],"knimeTypes":["String","Number (integer)"],"colTypes":["string","number"],"colorModels":[],"numExtensions":0}},"uuid":"bc25db9f-b8ba-4d8e-8c56-f7fe97d933e4","translator":{"mapping":{"Row0":["Row85","Row208","Row49","Row42","Row171","Row251","Row254","Row298","Row452","Row771","Row334","Row972","Row137","Row258","Row775","Row852","Row215","Row656","Row615","Row78","Row76","Row381","Row340","Row143","Row264","Row144","Row386","Row542","Row862","Row500","Row544","Row863","Row622","Row469","Row349","Row822","Row62","Row828","Row829","Row394","Row159","Row357","Row951","Row514","Row833","Row877","Row119","Row759","Row518","Row916","Row91","Row57","Row243","Row683","Row882","Row201","Row245","Row525"]},"sourceID":null,"targetIDs":null,"forward":false}}],"jsNamespace":"pie_chart_namespace","warnMessage":"","tableIds":["a2402966-a263-4220-9113-85a682cc8244"],"jsCode":["(pie_chart_namespace = function() {\n\n\tvar pie = {};\n\tvar _representation, _value;\n\tvar layoutContainer;\n\tvar MIN_HEIGHT = 100, MIN_WIDTH = 100;\n\tvar chart, svg;\n\tvar knimeTable;\n\t\n\tvar plotData;\n\tvar colorRange;\n\tvar excludeCat;\n\tvar missValCatValue;\n    var _translator;\n    var _keyNameMap;\n    var _incomingTable;\n\t\n\tvar showWarnings;\n\t\n\tvar MISSING_VALUES_ONLY = \"missingValuesOnly\";\n\tvar NO_DATA_AVAILABLE = \"noDataAvailable\";\n\n\tpie.init = function(representation, value) {\n\t\t_representation = representation;\n\t\t_value = value;\n\t\t_incomingTable = _representation.inObjects[0].table;\n\t\t\n\t\tif(_representation.options.enableSelection && _representation.inObjects[0].translator) {\n        \t_translator = _representation.inObjects[0].translator;\n        \t_translator.sourceID = _representation.inObjects[0].uuid;\n        \t_translator.targetIDs = [_representation.tableIds[0]];\n        \tknimeService.registerSelectionTranslator(_translator, _translator.sourceID);\n        \tsubscribeToSelection(_value.options.subscribeToSelection);\n        }\n\t\t\n\t\tshowWarnings = _representation.options.showWarnings;\n\t\t\n\t\tif (_representation.warnMessage && showWarnings) {\n\t\t\tknimeService.setWarningMessage(_representation.warnMessage);\n\t\t}\n\n\t\tdrawChart(false);\n\t\tif (_representation.options.enableViewControls) {\n\t\t\tdrawControls();\n\t\t}\n\t\t_keyNameMap = new KeyNameMap(getClusterToRowMapping());\n\t}\n\n\tfunction drawChart(redraw) {\t\t\n\t\t// Parse the options\n\t\tvar optTitle = _value.options[\"title\"];\n\t\tvar optSubtitle = _value.options[\"subtitle\"];\n\n\t\tvar showLabels = _value.options[\"showLabels\"];\n\t\tvar labelThreshold = _representation.options[\"labelThreshold\"];\n\t\tvar labelType = _value.options[\"labelType\"].toLowerCase();\n\t\t\t\t\n\t\tvar optDonutChart = _value.options[\"togglePie\"];\n\t\tvar holeSize = _value.options[\"holeSize\"];\n\t\tvar optInsideTitle = _value.options[\"insideTitle\"];\n\n\t\tvar showLegend = _representation.options[\"legend\"];\n\n\t\tvar optFullscreen = _representation.options[\"svg\"][\"fullscreen\"] && _representation.runningInView;\n\t\tvar optWidth = _representation.options[\"svg\"][\"width\"]\n\t\tvar optHeight = _representation.options[\"svg\"][\"height\"]\n\t\t\n\t\tvar optEnableSelection = _representation.options['enableSelection'];\n\t\t\n\t\tvar isTitle = optTitle || optSubtitle;\n\n\t\t/*\n\t\t * Setup interactive controls\n\t\t */\n\t\t\n\t\td3.select(\"html\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n        d3.select(\"body\").style(\"width\", \"100%\").style(\"height\", \"100%\");\n\n\t\tvar body = d3.select(\"body\");\n\n\t\tvar width = optWidth + \"px\";\n\t\tvar height = optHeight + \"px\";\n\t\tif (optFullscreen) {\n\t\t\twidth = \"100%\";\n\t\t\theight = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t}\n\t\t\n\t\tvar div;\n\t\tif (redraw) {\n\t\t\td3.select(\"svg\").remove();\n\t\t\tdiv = d3.select(\"#svgContainer\");\n\t\t} else {\n\t\t\tlayoutContainer = body.append(\"div\")\n\t\t\t\t.attr(\"id\", \"layoutContainer\")\n\t\t\t\t.attr('class', 'knime-layout-container')\t\t\t\t\n\t\t\t\t.style(\"width\", width)\n\t\t\t\t.style(\"height\", height)\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\t\t\n\t\t\t\n\t\t\tdiv = layoutContainer.append(\"div\")\n\t\t\t\t.attr(\"id\", \"svgContainer\")\n\t\t\t\t.attr('class', 'knime-svg-container')\n\t\t\t\t.style(\"min-width\", MIN_WIDTH + \"px\")\n\t\t\t\t.style(\"min-height\", MIN_HEIGHT + \"px\");\n\t\t}\n\n\t\t/*\n\t\t * Process data\n\t\t */\n\t\tknimeTable = new kt();\n\t\t// Add the data from the input port to the knimeTable.\n\t\tvar port0dataTable = _representation.inObjects[0].table;\n\t\tport0dataTable.rows = sortByClusterName(port0dataTable.rows);\n\t\tknimeTable.setDataTable(port0dataTable);\n\t\t\n\t\tprocessData(true);\t\n\t\tsetColorRange();\n\t\t\n\t\t// Create the SVG object\n\t\tvar svg1 = document\n\t\t\t\t.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\t\tdiv[0][0].appendChild(svg1);\n\n\t\tsvg = d3.select(\"svg\")\n\t\t\t.style(\"display\", \"block\");\n\n\t\tif (!optFullscreen) {\n\t\t\tif (optWidth > 0) {\n\t\t\t\tdiv.style(\"width\", optWidth + \"px\")\n\t\t\t\tsvg.attr(\"width\", optWidth);\n\t\t\t}\n\t\t\tif (optHeight > 0) {\n\t\t\t\tsvg.attr(\"height\", optHeight);\n\t\t\t\tdiv.style(\"height\", optHeight + \"px\");\n\t\t\t}\n\t\t} else {\n\t\t\t// Set full screen height/width\n\t\t\tdiv.style(\"width\", \"100%\");\n\t\t\tdiv.style(\"height\", height);\n\n\t\t\tsvg.attr(\"width\", \"100%\");\n\t\t\tsvg.attr(\"height\", \"100%\");\n\t\t}\n\t\n\t\t// Pie chart\n\t\tnv.addGraph(function() {\n\t\t\tchart = nv.models.pieChart()\n\t\t\t\t.x(function(d) { return d.label })\n\t\t\t\t.y(function(d) { return d.value })\n\t\t\t\t.color(colorRange)\n\t\t\t\t.duration(0)\n\t\t\t\t.showLegend(showLegend)\n\t\t\t\t.showLabels(showLabels)\n\t\t\t\t.labelThreshold(labelThreshold) \n\t\t\t\t.labelType(labelType); // \"key\", \"value\" or \"percent\"\n\n\t\t\tchart.dispatch.on('renderEnd.css', function() {\n\t\t\t\tsetCssClasses();\n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t// tooltip is re-created every time therefore we need to assign classes accordingly\n\t\t\tchart.pie.dispatch.on('elementMouseover.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.pie.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);\n\t\t\tchart.legend.dispatch.on('legendClick', function(series, index) {\n            \t//drawChart(true);\n            \tremoveHilightBar(\"\",true);\n            \td3.event.stopPropagation();\n            });\n\t\t\t\n\t\t\tchart.width(optFullscreen ? \"100%\" : optWidth);\n\t\t\tchart.height(optFullscreen ? \"100%\" : optHeight);\n\t\t\tchart.margin({top: 0, bottom: 0, left: 20, right: 0});\n\n\t\t\t// TODO: Add a mechanism to remember the categories that are\n\t\t\t// switched on.\n\n\t\t\tchart.donut(optDonutChart);\n\t\t\tchart.donutRatio(holeSize);\n\t\t\tif (optInsideTitle) {\n\t\t\t\tchart.title(optInsideTitle);\n\t\t\t}\n\t\t\tupdateTitles(false);\n\n\t\t\t// checking if all the pies are 0s\n\t\t\tif (plotData.filter(function(d) { return d.value !== 0 }).length === 0) {\n\t\t\t\tsvg.append('text')\n\t\t\t\t\t.attr('x', 20)\n\t\t\t\t\t.attr('y', 80)\n\t\t\t\t\t.attr('font-size', 20)\n\t\t\t\t\t.attr('fill', 'red')\n\t\t\t\t\t.text('The plot is empty because all values are equal to 0.');\n\t\t\t} else {\n\t\t\t\tsvg.datum(plotData).transition().duration(0).call(chart);\n\t\t\t}\n\t\t\t//nv.utils.windowResize(chart.update);\n\t\t\tnv.utils.windowResize(function () { \n\t\t\t\tchart.update(); \n\t\t\t\tremoveHilightBar(\"\",true); \n\t\t\t\tredrawSelection();\n\t\t\t});\n\t\t\t\n\t\t\tif(optEnableSelection) {\n\t\t\t\tsvg.on(\"click\", function() {\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t_value.options['selection'] = [];\n\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t// redraws selection\n            redrawSelection();\n\n\t\t\treturn chart;\n\t\t});\n\t}\n\t\n    function sortByClusterName(array) {\n        return array.sort(function(a, b) {\n            var x = a.data[0];\n            var y = b.data[0];\n            \n            // Make sure, that missing values are displayed last\n            if(x == null) {\n            \treturn 1\n            } else if (y == null) {\n            \treturn -1;\n            }\n            \n            if (typeof x == \"string\")\n            {\n                x = (\"\"+x).toLowerCase(); \n            }\n            if (typeof y == \"string\")\n            {\n                y = (\"\"+y).toLowerCase();\n            }\n            return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n        });\n    }\n\t\n    function registerClickHandler () {\n        d3.selectAll(\".nv-slice\").on('click',function(event) {\n            handleHighlightClick(event);\n            d3.event.stopPropagation();\n        });\n    }\n\n    function redrawSelection() {\n        var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n        for (var i = 0; i < length; i++) {\n            createHilightBar(_keyNameMap.getNameFromKey(_value.options['selection'][i][0]), \n                _value.options['selection'][i][1]);\n        }\n    }\n\n    function subscribeToSelection(subscribeBool) {\n        if(_representation.options.enableSelection) {\n            if(subscribeBool) {\n                knimeService.subscribeToSelection(_translator.sourceID, onSelectionChanged);\n            } else {\n                knimeService.unsubscribeSelection(_translator.sourceID, onSelectionChanged);\n            }\n        }\n    }\n\n    function publishSelection(shouldPublish){\n        if(shouldPublish) {\n            knimeService.setSelectedRows(_translator.sourceID, getSelectedRowIDs(), _translator.sourceID);\n        }\n    }\n\n    function checkClearSelectionButton(){\n        var button = d3.select(\"#clearSelectionButton\");\n        if (button){\n            button.classed(\"inactive\", function(){return !_value.options['selection'].length > 0});\n        }\n    }\n\n    function getSelectedRowIDs() {\n        if(_value.options['selection']) {\n            var selectedRowIDs = [];\n            for (var i = 0; i< _value.options['selection'].length; i++) {\n                selectedRowIDs.push( _value.options['selection'][i][0]);\n            }\n            return selectedRowIDs;\n        } else {\n            return [];\n        }\n    }\n\n    // Removes the clusterName with the given cluster name. If \"removeAll\" is true all bars are removed\n    function removeHilightBar(clusterName, removeAll) {\n        if (removeAll) {\n            var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n            for (var i = 0; i < length; i++) {\n                d3.selectAll(\".hilightBar\").remove();\n            }\n        } else {\n            var barIndex = getSelectedRowIDs().indexOf(_keyNameMap.getKeyFromName(clusterName));\n            if(barIndex > -1) {\n                let pie = selectCorrectBar(clusterName);\n                if (pie){\n                    pie.remove();\n                }\n            }\n        }\n    } \n\n    function selectCorrectBar(clusterName) {\n        let allSlices = d3.selectAll(\".nv-slice\");\n        for(var j = 0; j < allSlices[0].length; j++) {\n            if(d3.select(allSlices[0][j]).data()[0].data.label == clusterName) {\n                return d3.select(allSlices[0][j]).select(\".hilightBar\");\n            }\n        }\n    }\n\n    // Create a hilight-bar above the cluster with the given name and assigns the given css class to it\n    function createHilightBar (clusterName, selectionClass) {\n        for(var j = 0; j < plotData.length; j++) {\n            if(plotData[j].label === clusterName) {\n                var slices = d3.selectAll(\".nv-slice\");\n                for(var i = 0; i < slices[0].length; i++) {\n                    if(i==j) {\n                        var slice = d3.select(slices[0][i]).select(\"path\");\n                        var availableWidth = chart.width() - 20;\n                        var availableHeight = chart.height();\n                        var radius = Math.min(availableWidth, availableHeight) / 2;\n                        var selectionTitle;\n                        if(selectionClass == \"knime-selected\") {\n                            selectionTitle = \"Selected\";\n                        } else {\n                            selectionTitle = \"Partially selected\";\n                        }\n                        //PieChart Code\n                        var arc = d3.svg.arc()\n                        .innerRadius((radius - radius / 5))\n                        .outerRadius((radius - radius / 5)+8)\n                        .startAngle(slice.data()[0].startAngle) //converting from degs to radians\n                        .endAngle(slice.data()[0].endAngle); //just radians\n\n                        slice.select(function() { return this.parentNode; }).append(\"path\")\n                        .attr(\"d\", arc)\n                        .classed(\"hilightBar\",true)\n                        .classed(selectionClass, true)\n                        .append(\"title\")\n                        .classed('knime-tooltip', true)\n                        .text(selectionTitle);\n                    } \n                }\n            }\n        }\n    }\n\n    function getClusterToRowMapping() {\n        var map = {};\n        for (var i = 0; i < _incomingTable.rows.length; i++) {\n            if(_incomingTable.rows[i].data[0]) {\n                map[_incomingTable.rows[i].data[0]] = _incomingTable.rows[i].rowKey;\n            } else {\n                map[\"Missing values\"] = _incomingTable.rows[i].rowKey;\n            }\n        }\n        return map;\n    }\n\n    // Helper class to handle conversion from cluster name to row key\n    function KeyNameMap(map) {\n        this.map = map;\n        this.reverseMap = {};\n        for(var key in map){\n            var value = map[key];\n            this.reverseMap[value] = key;   \n        }\n    }\n\n    KeyNameMap.prototype.getKeyFromName = function(name){ \n        return this.map[name]; \n    }\n    KeyNameMap.prototype.getNameFromKey = function(key){\n        return this.reverseMap[key];\n    }\n\n    function handleHighlightClick(event) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        var clusterName = event.data.label;\n        var clusterKey = _keyNameMap.getKeyFromName(clusterName);\n        var barIndex = getSelectedRowIDs().indexOf(clusterKey);\n        // Deselect already selected bar when clicking again on it\n        if(barIndex > -1 && (d3.event.ctrlKey || d3.event.shiftKey || d3.event.metaKey)){\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.removeRowsFromSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, false);\n            _value.options['selection'].splice(barIndex, 1);\n        } else if(!d3.event.ctrlKey && !d3.event.shiftKey && !d3.event.metaKey) {\n            // Deselect all previously selected bars and select the newly clicked one\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.setSelectedRows(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            removeHilightBar(clusterName, true);\n            _value.options['selection']= [];\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        } else {\n            // Select the clicked bar, as it is either a new selection or a additional selection\n            if(_representation.options.enableSelection) {\n                if(_value.options.publishSelection) {\n                    knimeService.addRowsToSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n                }\n            }\n            createHilightBar(clusterName, \"knime-selected\");\n            _value.options['selection'].push([clusterKey, \"knime-selected\"]);\n        }\n        checkClearSelectionButton();\n    }\n\n    function onSelectionChanged(data) {\n        if(!_value.options['selection']) {\n            _value.options['selection'] = [];\n        }\n        if (data.reevaluate) {\n            removeHilightBar(\"\", true);\n            var selectedRows = knimeService.getAllRowsForSelection(_translator.sourceID);\n            var partiallySelectedRows = knimeService.getAllPartiallySelectedRows(_translator.sourceID);\n            _value.options['selection'] = [];\n            for (let selectedRow in selectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [selectedRows[selectedRow], \"knime-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(selectedRows[selectedRow]),\n                \"knime-selected\");\n            }\n            for (let partiallySelectedRow in partiallySelectedRows) {\n                let length = _value.options['selection'].length;\n                _value.options['selection'][length] = [partiallySelectedRows[partiallySelectedRow], \"knime-partially-selected\"];\n                createHilightBar(_keyNameMap.getNameFromKey(partiallySelectedRows[partiallySelectedRow]),\n                \"knime-partially-selected\");\n            }\n        } else if (data.changeSet) {\n            if (data.changeSet.removed) {\n                data.changeSet.removed.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if(data.changeSet.partialRemoved) {\n                data.changeSet.partialRemoved.map(function(rowId) {\n                    var clusterName = rowId;\n                    var index = getSelectedRowIDs().indexOf(clusterName);\n                    if (index > -1) {\n                        removeHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n                        _value.options['selection'].splice(index, 1);\n                    }\n                });\n            }\n            if (data.changeSet.added) {\n                data.changeSet.added.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-selected\");\n                    }\n                });\n            }\n            if(data.changeSet.partialAdded) {\n                data.changeSet.partialAdded.map(function(rowId) {\n                    var index = getSelectedRowIDs().indexOf(rowId);\n                    if (index === -1) {\n                        _value.options['selection'].push([rowId, \"knime-partially-selected\"]);\n                        createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-partially-selected\");\n                    }\n                });\n            }\n        }\n        checkClearSelectionButton();\n    }\n\n\t\n\tfunction updateData(updateChart) {\n\t\tprocessData();\n\t\tif (updateChart) {\n\t\t\tchart.update();\n\t\t}\n\t}\n\t\n\tfunction updateTitles(updateChart) {\n\t\tif (chart) {\n\t\t\tvar curTitle = d3.select(\"#title\");\n\t\t\tvar curSubtitle = d3.select(\"#subtitle\");\n\t\t\tvar chartNeedsUpdating = curTitle.empty() != !(_value.options.title) \n\t\t\t\t|| curSubtitle.empty() != !(_value.options.subtitle);\n\t\t\tif (!_value.options.title) {\n\t\t\t\tcurTitle.remove();\n\t\t\t}\n\t\t\tif (_value.options.title) {\n\t\t\t\tif (curTitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", 30)\n\t\t\t\t\t\t.attr(\"id\", \"title\")\n\t\t\t\t\t\t.attr('class', 'knime-title')\n\t\t\t\t\t\t.text(_value.options.title);\n\t\t\t\t} else {\n\t\t\t\t\tcurTitle.text(_value.options.title);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!_value.options.subtitle) {\n\t\t\t\tcurSubtitle.remove();\n\t\t\t} \n\t\t\tif (_value.options.subtitle) {\n\t\t\t\tif (curSubtitle.empty()) {\n\t\t\t\t\tsvg.append(\"text\")\n\t\t\t\t\t\t.attr(\"x\", 20)             \n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20)\n\t\t\t\t\t\t.attr(\"id\", \"subtitle\")\n\t\t\t\t\t\t.attr('class', 'knime-subtitle')\n\t\t\t\t\t\t.text(_value.options.subtitle);\n\t\t\t\t} else {\n\t\t\t\t\tcurSubtitle.text(_value.options.subtitle)\n\t\t\t\t\t\t.attr(\"y\", _value.options.title ? 46 : 20);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvar topMargin = 10;\n\t\t\ttopMargin += _value.options.title ? 10 : 0;\n\t\t\ttopMargin += _value.options.subtitle ? 8 : 0;\n\t\t\tchart.legend.margin({top: topMargin, bottom: topMargin});\n\t\t\tchart.margin({top: topMargin, bottom: topMargin});\n\t\t\t\n\t\t\tvar isTitle = _value.options.title || _value.options.subtitle;\n\t\t\tknimeService.floatingHeader(isTitle);\t\t\t\n\t\t\n\t\t\t\n\t\t\tif (updateChart && chartNeedsUpdating) {\n\t\t\t\tif (_representation.options.svg.fullscreen && _representation.runningInView ) {\n\t\t\t\t\tvar height = (isTitle) ? \"100%\" : \"calc(100% - \" + knimeService.headerHeight() + \"px)\";\n\t\t\t\t\tlayoutContainer.style(\"height\", height)\n\t\t\t\t\t\t// two rows below force to invalidate the container which solves a weird problem with vertical scroll bar in IE\n\t\t\t\t\t\t.style('display', 'none')\n\t\t\t\t\t\t.style('display', 'block');\n\t\t\t\t\td3.select(\"#svgContainer\").style(\"height\", height); \n\t\t\t\t}\n\t\t\t\tchart.update();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprocessData = function(setColorRange) {\n\t\tvar optMethod = _representation.options[\"aggr\"];\n\t\tvar optCat = _representation.options[\"cat\"];\n\t\tvar optFreqCol = _value.options[\"freq\"];\n\t\t\n\t\tvar categories = knimeTable.getColumn(optCat);\n\t\t\n\t\tvar valCol;\n\t\tif (optMethod == \"Occurence\\u00A0Count\") {\n\t\t\tvalCol = knimeTable.getColumn(1);\n\t\t} else {\n\t\t\tvalCol = knimeTable.getColumn(optFreqCol);\n\t\t}\n\t\t\n\t\tplotData = [];\n\t\texcludeCat = [];\n\t\tmissValCatValue = undefined;\n\t\tif (valCol.length > 0) {\n\t\t\tvar numDataPoints = valCol.length;\n\t\t\tfor (var i = 0; i < numDataPoints; i++) {\n\t\t\t\tvar label = categories[i];\n\t\t\t\tvar value = valCol[i];\n\t\t\t\t\n\t\t\t\tif (label === null) {\n\t\t\t\t\t// missing values category\t\t\t\t\t\n\t\t\t\t\t// save the value to append as the last item\t\t\t\t\t\t\n\t\t\t\t\tmissValCatValue = value;\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value === null) {\n\t\t\t\t\t// category has only missing values - exclude it\n\t\t\t\t\texcludeCat.push(label);\t\t\t\t\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar plotStream = {\n\t\t\t\t\t\"label\" : label,\n\t\t\t\t\t\"value\" : Math.abs(value)  // take abs value to prevent a damaged plot\n\t\t\t\t};\t\t\t\t\n\t\t\t\tplotData.push(plotStream);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprocessMissingValues(false);\n\t}\n\t\n\tsetColorRange = function() {\n\t\tvar numCat = plotData.length;\n\t\tif (missValCatValue !== undefined && missValCatValue !== null) {\n\t\t\t// We don't want the option \"includeMissValCat\" to influence on the number of categories,\n\t\t\t// because the option can be changed in the view and the color scale then can also be changed (if a border case) - and we don't want this.\n\t\t\t// Hence, only the real value matters.\n\t\t\tnumCat++;\n\t\t}\n\t\tif (_representation.options.customColors) {\n\t\t\tcolorRange = [];\n\t\t\tfor (var i = 0; i < numCat; i++) {\n\t\t\t\tvar color = knimeTable.getRowColors()[i];\n\t\t\t\tif (!color) {\n\t\t\t\t\tcolor = \"#7C7C7C\";\n\t\t\t\t}\n\t\t\t\tcolorRange.push(color);\n\t\t\t}\n\t\t} else {\n\t\t\tvar colorScale;\n\t\t\tif (numCat > 10) {\n\t\t\t\tcolorScale = d3.scale.category20();\n\t\t\t} else {\n\t\t\t\tcolorScale = d3.scale.category10();\n\t\t\t}\n\t\t\tcolorRange = colorScale.range();\n\t\t}\n\t}\n\t\n\t/**\n\t * switched - if the chart update was triggered by changing the \"include 'Missing values' category\" option in the view\n\t */\n\tprocessMissingValues = function(switched) {\n\t\t// Missing values post-processing\t\n\t\tif (missValCatValue !== undefined) {  // undefined means there's no missing value in the category column at all\n\t\t\tif (_value.options.includeMissValCat && _representation.options.reportOnMissingValues) {\n\t\t\t\t// add missing values category\n\t\t\t\tvar label = \"Missing values\";\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.push({\"label\": label, \"value\": missValCatValue});\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.push(label);\n\t\t\t\t}\n\t\t\t} else if (switched) {\n\t\t\t\t// remove missing values category, but only if we have triggered switch from the view\n\t\t\t\t// otherwise there's nothing to remove yet\n\t\t\t\tif (missValCatValue !== null) {\n\t\t\t\t\tplotData.pop();\n\t\t\t\t} else {\n\t\t\t\t\texcludeCat.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Set warning messages\n\t\tif (!showWarnings) {\n\t\t\treturn;\n\t\t}\n\t\tif (plotData.length == 0) {\n\t\t\t// No data available warnings\n\t\t\tvar str;\n\t\t\tif (missValCatValue !== undefined && missValCatValue !== null && _representation.options.reportOnMissingValues) {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values.\\nThere are values where the category name is missing.\\nTo see them switch on the option \\\"Include 'Missing values' category\\\" in the view settings.\";\n\t\t\t} else {\n\t\t\t\tstr = \"No chart was generated since the frequency column has only missing values or empty.\\nRe-run the workflow with different data.\";\n\t\t\t}\n\t\t\tknimeService.setWarningMessage(str, NO_DATA_AVAILABLE);\n\t\t} else if (excludeCat.length > 0 && _representation.options.reportOnMissingValues) {\n\t\t\tknimeService.setWarningMessage(\"Categories '\" + excludeCat.join(\"', '\") + \"' have only missing values in the frequency column and were excluded from the view.\", MISSING_VALUES_ONLY)\n\t\t} else {\n\t\t\tknimeService.clearWarningMessage(MISSING_VALUES_ONLY);\n\t\t}\t\n\t}\n\t\t\n\tdrawControls = function() {\t\t\n\t\tif (!knimeService) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (_representation.options.displayFullscreenButton) {\n\t\t\tknimeService.allowFullscreen();\n\t\t}\n\t\t\n\t    if (!_representation.options.enableViewControls) return;\n\t    \n\t    var titleEdit = _representation.options.enableTitleEdit;\n\t\tvar subtitleEdit = _representation.options.enableSubtitleEdit;\n\t\tvar donutToggle = _representation.options.enableDonutToggle;\n\t\tvar holeEdit = _representation.options.enableHoleEdit;\n\t\t//var insideTitleEdit = _representation.options.enableInsideTitleEdit;\n\t\t//var colChooser = _representation.options.enableColumnChooser;\n\t\tvar labelEdit = _representation.options.enableLabelEdit;\n\t\tvar switchMissValCat = _representation.options.enableSwitchMissValCat;\n\t\tvar enableSelection = _representation.options.enableSelection;\n\t\tvar displayClearButton = _representation.options.displayClearSelectionButton;\n\t    \n\t    if (titleEdit || subtitleEdit) {\t    \t    \n\t    \tif (titleEdit) {\n\t    \t\tvar chartTitleText = knimeService.createMenuTextField('chartTitleText', _value.options.title, function() {\n\t    \t\t\tif (_value.options.title != this.value) {\n\t\t\t\t\t\t_value.options.title = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tknimeService.addMenuItem('Chart Title:', 'header', chartTitleText);\n\t    \t}\n\t    \tif (subtitleEdit) {\n\t    \t\tvar chartSubtitleText = knimeService.createMenuTextField('chartSubtitleText', _value.options.subtitle, function() {\n\t    \t\t\tif (_value.options.subtitle != this.value) {\n\t\t\t\t\t\t_value.options.subtitle = this.value;\n\t\t\t\t\t\tupdateTitles(true);\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tvar mi = knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null, knimeService.SMALL_ICON);\n\t    \t}\t\n\t    \tif (/*colChooser ||*/ labelEdit || donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    /*if (colChooser) {\n\t    \t// filter out non number columns\n\t    \tvar colNames = _representation.inObjects[0].spec.colNames;\n\t\t\tvar colTypes = _representation.inObjects[0].spec.colTypes;\n\t\t\tvar numberColumns = [];\n\t\t\tfor (var i = 0; i < colNames.length; i++) {\n\t\t\t\tif (colTypes[i] == \"number\") {\n\t\t\t\t\tnumberColumns.push(colNames[i]);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n    \t\tvar colSelect = knimeService.createMenuSelect('columnSelect', _value.options.freq, numberColumns, function() {\n    \t\t\t_value.options.freq = this.value;\n\t\t\t\tupdateData(true);\n    \t\t});\n    \t\tknimeService.addMenuItem('Column:', 'minus-square fa-rotate-90', colSelect);\n    \t\t\n    \t\tif (labelEdit || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n        }*/\n\t    \n\t    if (labelEdit) {\n\t    \tvar labelCbx = knimeService.createMenuCheckbox('labelCbx', _value.options.showLabels, function () {\n\t    \t\tif (_value.options.showLabels != this.checked) {\n\t\t\t\t\t_value.options.showLabels = this.checked;\n\t\t\t\t\tchart.showLabels(this.checked);\n\t\t\t\t\td3.selectAll(\"#labelType input\").property(\"disabled\", !_value.options.showLabels);\n\t\t\t\t\t//workaround for nvd3 bug, remove labels manually\n\t\t\t\t\tif (!this.checked) {\n\t\t\t\t\t\td3.selectAll(\".nv-pieLabels *\").remove();\n\t\t\t\t\t}\n\t\t\t\t\tchart.update();\n\t\t\t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem('Show labels:', 'comment-o', labelCbx);\n\t    \t\n\t    \tvar labelTypeRadio = knimeService.createInlineMenuRadioButtons('labelType', 'labelType', 'Value', ['Key', 'Value', 'Percent'], function() {\n\t    \t\t_value.options.labelType = this.value;\n\t\t\t\tchart.labelType(this.value.toLowerCase());\n\t\t\t\tchart.update();\n\t    \t});\n\t    \tknimeService.addMenuItem('Label type:', 'commenting-o', labelTypeRadio);\n\t    \t\n\t\t    if (switchMissValCat || donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (switchMissValCat && missValCatValue !== undefined && _representation.options.reportOnMissingValues) {\n\t    \tvar switchMissValCatCbx = knimeService.createMenuCheckbox('switchMissValCatCbx', _value.options.includeMissValCat, function() {\n\t    \t\tif (_value.options.includeMissValCat != this.checked) {\n\t    \t\t\t_value.options.includeMissValCat = this.checked;\n\t    \t\t\tprocessMissingValues(true);\n\t    \t\t\tchart.update();\n\t    \t\t}\n\t    \t});\n\t    \tknimeService.addMenuItem(\"Include 'Missing values' category: \", 'question', switchMissValCatCbx);\n\t    \t\n\t    \tif (donutToggle || holeEdit || insideTitleEdit) {\n\t    \t\tknimeService.addMenuDivider();\n\t    \t}\n\t    }\n\t    \n\t    if (donutToggle || holeEdit /*|| insideTitleEdit*/) {\n\t    \tif (donutToggle) {\n\t\t    \tvar donutCbx = knimeService.createMenuCheckbox('donutCbx', _value.options.togglePie, function () {\n\t\t    \t\tif (_value.options.togglePie != this.checked) {\n\t\t\t\t\t\t_value.options.togglePie = this.checked;\n\t\t\t\t\t\tchart.donut(this.checked);\n\t\t\t\t\t\td3.selectAll(\"#insideTitleText, #holeRatioText\").property(\"disabled\", !_value.options.togglePie);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t\t    \t});\n\t\t    \tknimeService.addMenuItem('Render donut chart:', knimeService.createStackedIcon('gear', 'circle-o'), donutCbx);\n\t    \t}\n\t    \t\n\t    \tif (holeEdit) {\n\t    \t\tvar holeRatioText = knimeService.createMenuTextField('holeRatioText', _value.options.holeSize, function() {\n\t    \t\t\tif (this.value < 0) {\n    \t\t\t\t\tthis.value = 0;\n    \t\t\t\t} else if (this.value > 1) {\n    \t\t\t\t\tthis.value = 1;\n    \t\t\t\t}\n    \t\t\t\tchart.donutRatio(this.value);\n    \t\t\t\tchart.update();\n\t    \t\t}, true);\n\t    \t\tholeRatioText.setAttribute(\"type\", \"number\");\n\t    \t\tholeRatioText.setAttribute(\"min\", 0);\n\t    \t\tholeRatioText.setAttribute(\"max\", 1);\n\t    \t\tholeRatioText.setAttribute(\"step\", 0.1);\n\t    \t\tholeRatioText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Donut hole ratio:', 'adjust', holeRatioText);\n\t    \t}\n\t    \t\n\t    \t/*if (insideTitleEdit) {\n\t    \t\tvar insideTitleText = knimeService.createMenuTextField('insideTitleText', _value.options.insideTitle, function() {\n\t    \t\t\tif (_value.options.insideTitle != this.value) {\n\t\t\t\t\t\t_value.options.insideTitle = this.value;\n\t\t\t\t\t\tchart.title(this.value);\n\t\t\t\t\t\tchart.update();\n\t\t\t\t\t}\n\t    \t\t}, true);\n\t    \t\tinsideTitleText.disabled = !_value.options.togglePie;\n\t    \t\tknimeService.addMenuItem('Title inside:', 'header', insideTitleText, null, knimeService.SMALL_ICON);\n\t    \t}*/\n\t    \t\n\t        if (enableSelection) {\n\t        \tknimeService.addMenuDivider();\n\t        \tvar subscribeToSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-double-right', 'faded right sm', 'left bold');\n\t        \tvar subscribeToSelectionMenu = knimeService.createMenuCheckbox('subscribeToSelection', \n\t        \t\t\t_value.options.subscribeToSelection, function () {\n\t        \t\tif (_value.options.subscribeToSelection != this.checked) {\n\t        \t\t\t_value.options.subscribeToSelection = this.checked;\n\t        \t\t\tsubscribeToSelection(_value.options.subscribeToSelection);\n\t        \t\t}\n\t        \t});\n\t        \tknimeService.addMenuItem('Subscribe to selection:', subscribeToSelectionIcon, subscribeToSelectionMenu);\n\t        \t\n\t        \tvar publishSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-right', 'faded left sm', 'right bold');\n\t            var publishSelectionMenu = knimeService.createMenuCheckbox('publishSelection', _value.options.publishSelection,\n\t                function () {\n\t                    if (_value.options.publishSelection != this.checked) {\n\t                        _value.options.publishSelection = this.checked;\n\t                        publishSelection(this.checked);\n\t                    }\n\t                });\n\t            knimeService.addMenuItem('Publish selection:', publishSelectionIcon, publishSelectionMenu);\n\t        }\n\t        \n\t        if (displayClearButton &&  _representation.options.enableSelection) {\n\t\t\t\tknimeService.addButton(\"clearSelectionButton\", \"minus-square-o\", \"Clear selection\", function(){\n\t\t\t\t\td3.selectAll(\".row\").classed({\"selected\": false, \"knime-selected\": false, \"unselected\": false });\n\t\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t\t_value.options['selection'] = [];\n\t\t\t\t\tpublishSelection(true);\n\t\t\t\t});\n\t\t\t\td3.select(\"#clearSelectionButton\").classed(\"inactive\", true);\n\t\t\t}\n    \t}\n\t};\n\n\tfunction setCssClasses() {\t\t\n\t\td3.selectAll('.nv-label')\n\t\t\t.classed('knime-label', true);\n\n\t\t// legend\n\t\td3.selectAll('.nv-legendWrap')\n\t\t\t.classed('knime-legend', true);\n\t\td3.selectAll('.nv-legend-symbol')\n\t\t\t.classed('knime-legend-symbol', true);\n\t\td3.selectAll('.nv-legend-text')\n\t\t\t.classed('knime-legend-label', true);\n\t\tif(_representation.options['enableSelection']) {\n\t\t\tregisterClickHandler();\n\t\t}\n\t}\n\t\n\tfunction setTooltipCssClasses() {\n\t\t// tooltip\n\t\tvar tooltip = d3.selectAll('.nvtooltip')\n\t\t.classed('knime-tooltip', true);\n\t\ttooltip.selectAll('.x-value')\n\t\t.classed('knime-tooltip-caption', true)\n\t\t.classed('knime-x', true);\n\t\ttooltip.selectAll('.legend-color-guide')\n\t\t.classed('knime-tooltip-color', true);\n\t\ttooltip.selectAll('.key')\n\t\t.classed('knime-tooltip-key', true);\n\t\ttooltip.selectAll('.value')\n\t\t.classed('knime-tooltip-value', true);\n\t}\n\n\tpie.validate = function() {\n\t\treturn true;\n\t}\n\n\tpie.getComponentValue = function() {\n\t\treturn _value;\n\t}\n\n\tpie.getSVG = function() {\t\t\n\t\t// correct faulty rect elements\n\t\td3.selectAll(\"rect\").each(function() {\n\t\t\tvar rect = d3.select(this);\n\t\t\tif (!rect.attr(\"width\")) {\n\t\t\t\trect.attr(\"width\", 0);\n\t\t\t}\n\t\t\tif (!rect.attr(\"height\")) {\n\t\t\t\trect.attr(\"height\", 0);\n\t\t\t}\n\t\t});\n\t\t\n\t\tvar svgElement = d3.select(\"svg\")[0][0];\n\t\tknimeService.inlineSvgStyles(svgElement);\n\n\t\t// Return the SVG as a string.\n\t\treturn (new XMLSerializer()).serializeToString(svgElement);\n\t}\n\n\treturn pie;\n\n}());"],"cssCode":["text.knime-tick-label.knime-selected {\n\tfont-weight: bold;\n}\npath.knime-selected {\n\tfill: orange;\n\t\n}\npath.knime-partially-selected {\n\tfill: grey;\n}\ntext.knime-tick-label.knime-partially-selected {\n\tfont-weight: bold;\n}\n\npath.nv-bar.positive {\n\tcursor:pointer;\n}"],"flowVariables":{"knime.workspace":"C:\\Users\\mehar\\knime-workspace","css-stylesheet":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-size: 12px; \n}\n\n.knime-label {\n\tcolor: white;\n}\n"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Pie/Donut Chart (JavaScript)"}},"58:0:39":{"@class":"org.knime.js.core.JSONWebNode","namespace":"dynamicJSNode","initMethodName":"init","validateMethodName":"validate","setValidationErrorMethodName":"setValidationError","javascriptLibraries":["/js-lib/knime/service/knime_service_1_0_0.js","/js-lib/requireJS/2.1.8/require.js","/js-lib/knime/knime_table_1_0_0.js","/org/knime/dynamic/js/dynamicJSNode.js"],"getViewValueMethodName":"getComponentValue","customCSS":"","stylesheets":["/js-lib/font-awesome/4_7_0/css/font-awesome.min.css","/js-lib/knime/service/knime.css"],"viewValue":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewValue","options":{"catLabel":"ItemSets","includeMissValCat":true,"orientation":false,"freqLabel":"Amount","staggerLabels":true,"subtitle":"Top 10 Frequent Patterns","chartType":"Grouped","title":"Monthly Benefits vs Sum Insured","subscribeToSelection":true,"publishSelection":true,"showMaximum":true},"tables":{},"outColumns":{},"flowVariables":{}},"viewRepresentation":{"@class":"org.knime.dynamic.js.v30.DynamicJSViewRepresentation","runningInView":true,"options":{"displayFullscreenButton":true,"displayClearSelectionButton":true,"svg":{"width":800,"height":600,"fullscreen":false},"legend":true,"enableHorizontalToggle":true,"freq":["Sum(Monthly Benefit)","Sum(Sum Insured)"],"tooltip":true,"enableTitleEdit":true,"enableSelection":true,"sort":false,"enableSwitchMissValCat":true,"enableStackedEdit":true,"enableAxisEdit":true,"processInMemory":true,"reportOnMissingValues":true,"cat":"Count*(Sum Insured)","enableStaggerToggle":true,"enableViewControls":true,"showWarnings":true,"enableSubtitleEdit":true,"aggr":"Sum","enableMaximumValue":true},"cssDependencies":["js-lib/nvd3/1.8.6/nv.d3.min.css"],"jsDependencies":[{"name":"nvd3","path":"js-lib/nvd3/1.8.6/nv.d3.min.js","dependencies":["D3_3.5.5"],"local":true,"usesDefine":false,"exports":"nv"},{"name":"D3_3.5.5","path":"js-lib/d3/d3.v3_5_5.min.js","dependencies":[],"local":true,"usesDefine":false,"exports":null}],"errorMessage":"","binaryFiles":{},"inObjects":[{"table":{"@class":"org.knime.js.core.JSONDataTable","id":"6156c87c-cadc-44fc-9069-37072e8d73eb","extensions":null,"rows":[{"data":["71",227259.52000000002,232214.0],"rowKey":"Row0"},{"data":["61",276779.82,283179.0],"rowKey":"Row1"},{"data":["52",196153.11000000004,209318.0],"rowKey":"Row2"},{"data":["51",216095.2,237172.0],"rowKey":"Row3"},{"data":["33",83858.76,89149.0],"rowKey":"Row4"},{"data":["31",115371.87,124253.0],"rowKey":"Row5"},{"data":["22",89864.18000000002,103989.0],"rowKey":"Row6"},{"data":["19",75501.83,80224.0],"rowKey":"Row7"},{"data":["16",111399.77,79154.0],"rowKey":"Row8"},{"data":["15",68351.22,68858.0],"rowKey":"Row9"}],"dataHash":null,"spec":{"@class":"org.knime.js.core.JSONDataTableSpec","numColumns":3,"possibleValues":[["71","61","52","51","33","31","22","19","16","15"],null,null],"containsMissingValues":[false,false,false],"rowColorValues":["#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040","#404040"],"numRows":10,"extensionNames":[],"extensionTypes":[],"filterIds":[null,null,null],"maxValues":["71",276779.82,283179.0],"hiddenColumns":[],"rowSizeValues":null,"minValues":["15",68351.22,68858.0],"colNames":["Count*(Sum Insured)","Sum(Monthly Benefit)","Sum(Sum Insured)"],"knimeTypes":["String","Number (double)","Number (double)"],"colTypes":["string","number","number"],"colorModels":[],"numExtensions":0}},"uuid":"10a9e6bd-71aa-4016-a540-cb157501994c","translator":{"mapping":{"Row0":["Row86"],"Row1":["Row84"],"Row8":["Row31"],"Row9":["Row90"],"Row6":["Row96"],"Row7":["Row110"],"Row4":["Row178"],"Row5":["Row24"],"Row2":["Row176"],"Row3":["Row23"]},"sourceID":null,"targetIDs":null,"forward":false}},null],"jsNamespace":"grouped_bar_chart_namespace","warnMessage":"","tableIds":["c0a7d1a3-cd24-4b4b-8bab-60674d331fba",null],"jsCode":["/* global knimeService:false, d3:false, kt:false, nv:false */\n(grouped_bar_chart_namespace = function () {\n\n    var barchart = {};\n    var layoutContainer;\n    var MIN_HEIGHT = 100, MIN_WIDTH = 100;\n    var _representation, _value;\n    var chart, svg;\n    var knimeTable;\n\n    var plotData;\n    var wrapedPlotData;\n    var colorRange;\n    var categories;\n    var freqCols;\n    var _translator;\n    var _keyNameMap;\n    var _incomingTable;\n\n    /**\n\t * 2d-array where for each category (indexing follows categories array) we\n\t * store an array of those frequency columns, which have a missing value in\n\t * the current category. This allows to exclude specific bars or even the\n\t * whole category. Storing by category helps to group warnings also by\n\t * category. Required for missing values handling.\n\t */\n    var missValInCat;\n\n    /**\n\t * Array where for each frequency column, which has in all other categories\n\t * only missing values, we store whether it has a value in the Missing\n\t * values category. This allows to decide, if we should keep this freq\n\t * column (if it has a value in MissValCat and the option \"include\n\t * MissValCat\" is on) or exclude it. Each item has the fields: col - name of\n\t * freq column hasValueOnMissValCat - whether the column has a non-missing\n\t * value in the Missing values category (true/false) Required for missing\n\t * values handling.\n\t */\n    var freqColValueOnMissValCat;\n\n    /**\n\t * Array where for each frequency column, which has non-missing value in the\n\t * Missing values category, we store this value. We need to store it\n\t * separately to quickly add/remove them to the plot data, when the option\n\t * \"include MissValCat\" is getting switched. Each item has the fields: col -\n\t * name of freq column value - non-missing value, this freq column has in\n\t * the Missing values category Required for missing values handling.\n\t */\n    var missValCatValues;\n\n    /**\n\t * Boolean flag - is the Missing values category present in the dataset.\n\t * Required for missing values handling.\n\t */\n    var isMissValCat;\n\n    /**\n\t * Map where keys - frequency column names, values - array of those\n\t * categories for which the bar, specified by the corresponding freq column\n\t * and the category, was excluded from the view. There excluded bars\n\t * actually specify those dummy null values, we have to add to the stacked\n\t * chart to fix it. Choosing freq cols as keys helps adding dummy nulls\n\t * since the plot dataset has to be key->values. Required for missing values\n\t * handling.\n\t */\n    var excludeFreqColCatMap;\n    \n    var showWarnings;\n\n    var MISSING_VALUES_LABEL = 'Missing values';\n    var MISSING_VALUES_ONLY = 'missingValuesOnly';\n    var FREQ_COLUMN_MISSING_VALUES_ONLY = 'freqColumnMissingValuesOnly';\n    var CATEGORY_MISSING_VALUES_ONLY = 'categoryMissingValuesOnly';\n    var NO_DATA_AVAILABLE = 'noDataAvailable';\n\n    barchart.init = function (representation, value) {\n        _value = value;\n        _representation = representation;\n        _incomingTable = _representation.inObjects[0].table;\n\n        if (_representation.options.enableSelection && _representation.inObjects[0].translator) {\n        \t_translator = _representation.inObjects[0].translator;\n        \t_translator.sourceID = _representation.inObjects[0].uuid;\n        \t_translator.targetIDs = [_representation.tableIds[0]];\n        \tknimeService.registerSelectionTranslator(_translator, _translator.sourceID);\n        \tsubscribeToSelection(_value.options.subscribeToSelection);\n        }\n        \n        showWarnings = _representation.options.showWarnings;\n\n        if (_representation.warnMessage && showWarnings) {\n            knimeService.setWarningMessage(_representation.warnMessage);\n        }\n        if (_representation.options.enableViewControls) {\n            drawControls();\n        }\n        drawChart();\n\n        _keyNameMap = new KeyNameMap(getClusterToRowMapping());\n    };\n    \n\n    function drawChart(redraw) {\n\n        d3.select('html').style('width', '100%').style('height', '100%');\n        d3.select('body').style('width', '100%').style('height', '100%');\n        /*\n\t\t * Process options\n\t\t */\n        var viewControls = _representation.options.enableViewControls;\n        var optWidth = _representation.options['width'];\n        var optHeight = _representation.options['height'];\n\n        var optTitle = _value.options['title'];\n        var optSubtitle = _value.options['subtitle'];\n        var optCatLabel = _value.options['catLabel'];\n        var optFreqLabel = _value.options['freqLabel'];\n\n        var sortLabels = _representation.options['sort'];\n        var optStaggerLabels = _value.options['staggerLabels'];\n        var optLegend = _representation.options['legend'];\n        var optTooltips = _representation.options['tooltip'];\n\n        var optOrientation = _value.options['orientation'];\n\n        var optFullscreen = _representation.options['svg']['fullscreen'] && _representation.runningInView;\n        var optWidth = _representation.options['svg']['width'];\n        var optHeight = _representation.options['svg']['height'];\n        var optEnableSelection = _representation.options['enableSelection'];\n\n        var isTitle = optTitle || optSubtitle;\n\n        var body = d3.select('body');\n\n        var width = optWidth + 'px';\n        var height = optHeight + 'px';\n        if (optFullscreen) {\n            knimeService.floatingHeader(isTitle);\n            width = '100%';\n            height = (isTitle) ? '100%' : 'calc(100% - ' + knimeService.headerHeight() + 'px)';\n        }\n\n        var div;\n        if (redraw) {\n            d3.select('svg').remove();\n            div = d3.select('#svgContainer');\n        } else {\n            layoutContainer = body.append('div')\n                .attr('id', 'layoutContainer')\n                .attr('class', 'knime-layout-container')\n                .style('width', width)\n                .style('height', height)\n                .style('min-width', MIN_WIDTH + 'px')\n                .style('min-height', MIN_HEIGHT + 'px');\n\n            div = layoutContainer.append('div')\n                .attr('id', 'svgContainer')\n                .attr('class', 'knime-svg-container')\n                .style('min-width', MIN_WIDTH + 'px')\n                .style('min-height', MIN_HEIGHT + 'px');\n        }\n\n        var svg1 = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        div[0][0].appendChild(svg1);\n\n        svg = d3.select('svg')\n            .style('display', 'block')\n            .classed('colored', true);\n        \n        \n        // handle clicks on background to deselect current selection\n        if(optEnableSelection) {\n\t        svg.on(\"click\", function() {\n\t        \tremoveHilightBar(\"\", true);\n\t        \t_value.options['selection'] = [];\n\t        \tpublishSelection(true);\n\t        });\n        }\n        \n\n        if (!optFullscreen) {\n            if (optWidth > 0) {\n                div.style('width', optWidth + 'px');\n                svg.attr('width', optWidth);\n                // Looks like the below doesn't work,\n                // above does work...\n                // chart.width(optWidth);\n            }\n            if (optHeight > 0) {\n                svg.attr('height', optHeight);\n                div.style('height', optHeight + 'px');\n                // Looks like the below doesn't work,\n                // above does work...\n                // chart.height(optHeight);\n            }\n        } else {\n            // Set full screen height/width\n            div.style('width', '100%');\n            div.style('height', height /*TODO: this should be 100% always, but for some reason that doesn't work*/);\n\n            svg.attr('width', '100%');\n            svg.attr('height', '100%');\n        }\n\n        if (!redraw) {\n            /*\n\t\t\t * Process data\n\t\t\t */\n            knimeTable = new kt();\n            // Add the data from the input port to the knimeTable.\n            var port0dataTable = _representation.inObjects[0].table;\n            if (!_representation.isHistogram && sortLabels) {\n                port0dataTable.rows = sortByClusterName(port0dataTable.rows);\n            }\n            knimeTable.setDataTable(port0dataTable);\n\n            processData();\n        }\n\n        /*\n\t\t * Plot chart\n\t\t */\n        nv.addGraph(function () {\n            if (optOrientation) {\n                chart = nv.models.multiBarHorizontalChart();\n            } else {\n                chart = nv.models.multiBarChart();\n                chart.reduceXTicks(!!_representation.isHistogram);\n                /*if (_representation.options.rotateLabels) {\n                    chart.rotateLabels(_representation.options.rotateLabels);\n                }*/\n            }\n\n            chart.dispatch.on('renderEnd.css', function() {\n            \tsetCssClasses();\n            });\n            // tooltip is re-created every time therefore we need to assign\n            // classes accordingly\n            chart.multibar.dispatch.on('elementMouseover.tooltipCss', setTooltipCssClasses);\n            chart.multibar.dispatch.on('elementMousemove.tooltipCss', setTooltipCssClasses);\n            chart.legend.dispatch.on('legendClick', function(series, index) {\n            \tdrawChart(true);\n            \td3.event.stopPropagation();\n            });\n\n            var stacked = _value.options.chartType == 'Stacked';\n            if (stacked) {\n                fixStackedData(true); // add dummy nulls\n            }\n            chart.stacked(stacked);\n\n            chart\n                .color(colorRange)\n                .duration(0)\n                .margin({ right: 20 })\n                .groupSpacing(_representation.isHistogram ? 0.01 : 0.1);\n\n            updateTitles(false);\n\n            chart.showControls(false); // all the controls moved to settings menu\n            chart.showLegend(optLegend);\n            chart.tooltip.enabled((typeof optTooltips === 'undefined') || optTooltips);\n\n            updateAxisLabels(false);\n            svg.datum(plotData).transition().duration(0).call(chart);\n            nv.utils.windowResize(function () { \n            \tupdateAxisLabels(true); \n            \tupdateLabels(); \n            \tsetCssClasses(); \n            \tremoveHilightBar(\"\",true);\n            \tredrawSelection();\n        \t});\n            \n            // redraws selection\n            if(_value.options['selection']) {\n            \tredrawSelection();\n            }\n            return chart;\n        });\n    }\n    \n    function sortByClusterName(array) {\n        return array.sort(function(a, b) {\n            var x = a.data[0];\n            var y = b.data[0];\n            \n            // Make sure, that missing values are displayed last\n            if(x == null) {\n            \treturn 1\n            } else if (y == null) {\n            \treturn -1;\n            }\n            \n            if (typeof x == \"string\")\n            {\n                x = (\"\"+x).toLowerCase(); \n            }\n            if (typeof y == \"string\")\n            {\n                y = (\"\"+y).toLowerCase();\n            }\n            return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n        });\n    }\n    \n    function registerClickHandler () {\n    \td3.selectAll(\".nv-bar\").on('click',function(event) {\n\t\t\thandleHighlightClick(event);\n\t\t\td3.event.stopPropagation();\n    \t});\n    }\n    \n    function getActiveBars() {\n    \tvar stacked = _value.options['chartType'];\n    \tvar counter = 0;\n    \tif(stacked == \"Stacked\") {\n    \t\tcounter = 1;\n    \t} else {\n    \t\tfor (var j = 0; j < plotData.length; j++) { \n    \t\t\tif(plotData[j].disabled !== true) {\n    \t\t\t\tcounter ++;\n    \t\t\t} \n    \t\t}\n    \t}\n    \treturn counter;\n    }\n\n\tfunction redrawSelection() {\n\t    var length = _value.options['selection'] ? _value.options['selection'].length : 0;\n        for (var i = 0; i < length; i++) {\n            createHilightBar(_keyNameMap.getNameFromKey(_value.options['selection'][i][0]),\n                _value.options['selection'][i][1]);\n        }\n    }\n    \n    function subscribeToSelection(subscribeBool) {\n        if (_representation.options.enableSelection) {\n            if (subscribeBool) {\n                knimeService.subscribeToSelection(_translator.sourceID, onSelectionChanged);\n            } else {\n                knimeService.unsubscribeSelection(_translator.sourceID, onSelectionChanged);\n            }\n        }\n    }\n    \n    function publishSelection(shouldPublish){\n    \tif(shouldPublish) {\n    \t\tknimeService.setSelectedRows(_translator.sourceID, getSelectedRowIDs(), onSelectionChanged);\n    \t}\n    }\n    \n\tfunction checkClearSelectionButton(){\n\t\tif(_value.options['selection']){\n\t\t\tvar button = d3.select(\"#clearSelectionButton\");\n\t\t\tif (button){\n\t\t\t\tbutton.classed(\"inactive\", function(){return !_value.options['selection'].length > 0});\n\t\t\t}\n\t\t}\n\t}\n    \n    function getSelectedRowIDs() {\n    \tif(_value.options['selection']) {\n\t    \tvar selectedRowIDs = [];\n\t    \tfor (var i = 0; i< _value.options['selection'].length; i++) {\n\t    \t\tselectedRowIDs.push( _value.options['selection'][i][0]);\n\t    \t}\n\t    \treturn selectedRowIDs;\n    \t} else {\n    \t\treturn [];\n    \t}\n    }\n    \n    function selectCorrectBar(clusterName) {\n    \tvar allBars = d3.selectAll(\".knime-x text.knime-tick-label\");\n    \tfor(var j = 0; j < allBars[0].length; j++) {\n    \t\tif(d3.select(allBars[0][j]).data()[0] == clusterName) {\n    \t\t\treturn d3.select(allBars[0][j]);\n    \t\t}\n    \t}\n    }\n    \n    // Removes the clusterName with the given cluster name. If \"removeAll\" is true all bars are removed\n    function removeHilightBar(clusterName, removeAll) {\n        if (_value.options['selection']){\n            if (removeAll) {\n                var length = _value.options['selection'].length;\n                for (var i = 0; i < length; i++) {\n                    var selectedEntry = _value.options['selection'][i];\n                    var bars = d3.selectAll(\".hilightBar\");\n                    var barParent = bars.select(function() { return this.parentNode; });\n                    barParent.select(\"text\").classed(selectedEntry[1], false);\n                    d3.selectAll(\".hilightBar\").remove();\n                }\n            } else {\n                var barIndex = getSelectedRowIDs().indexOf(_keyNameMap.getKeyFromName(clusterName));\n                if (barIndex > -1) {\n                    var selectedEntry = _value.options['selection'][barIndex];\n                    var bar = selectCorrectBar(clusterName);\n                    if(bar){\n                        var barParent = bar.select(function() { return this.parentNode; });\n                        barParent.select(\"text\").classed(selectedEntry[1], false);\n                        barParent.selectAll(\".hilightBar\").remove();\n                    }\n                }\n            }\n        }\n    } \n    \n    // Create a hilight-bar above the cluster with the given name and assigns the given css class to it\n    function createHilightBar (clusterName, selectionClass) {\n    \tvar optOrientation = _value.options['orientation'];\n\t  \t\tfor(var k = 0; k < plotData.length; k++) {\n\t  \t\t\tfor(var j = 0; j < plotData[k].values.length; j++) {\n\t\t  \t\tif(plotData[k].values[j].x === clusterName) {\n\t\t  \t\t\td3.selectAll(\".knime-x text\").each(function(d,i) {\n\t\t  \t\t\t\tif(i==j) {\n\t\t  \t\t\t\t\td3.select(this).classed(selectionClass,true);\n\t\t  \t\t\t\t\tvar selectionTitle;\n\t\t  \t\t\t\t\tif(selectionClass == \"knime-selected\") {\n\t\t  \t\t\t\t\t\tselectionTitle = \"Selected\";\n\t\t  \t\t\t\t\t} else {\n\t\t  \t\t\t\t\t\tselectionTitle = \"Partially selected\";\n\t\t  \t\t\t\t\t}\n\t\t  \t\t\t\t\tvar posX = 0;\n\t\t  \t\t\t\t\tvar posY = 0;\n\t\t  \t\t\t\t\tvar highlightHeight = 0;\n\t\t  \t\t\t\t\tvar highlightWidth = 5;\n\t\t  \t\t\t\t\tif(optOrientation) {\n\t\t  \t\t\t\t\t\tposY = -0.5*(d3.select(\".nv-bar.positive\").node().getBBox().height * getActiveBars());\n\t\t  \t\t\t\t\t\tposX = -1.5*highlightWidth;\n\t\t  \t\t\t\t\t\thighlightHeight = (d3.select(\".nv-bar.positive\").node().getBBox().height) * getActiveBars();\n\t\t  \t\t\t\t\t} else {\n\t\t  \t\t\t\t\t\t\tposX = -0.5*(d3.select(\".nv-bar.positive\").node().getBBox().width * getActiveBars());\n\t\t\t  \t\t\t\t\t\thighlightWidth = (d3.select(\".nv-bar.positive\").node().getBBox().width) * getActiveBars();\n\t\t\t  \t\t\t\t\t\thighlightHeight = 5;\n\t\t\t  \t\t\t\t\t\tposY = 0.5*highlightHeight;\n\t\t  \t\t\t\t\t}\n\t    \t  \t\t\t\td3.select(this.parentNode).append(\"rect\").classed(\"hilightBar\",true)\n\t    \t  \t\t\t\t.classed(selectionClass, true)\n\t    \t  \t\t\t\t.attr({ x: posX, y: posY, width: highlightWidth, height: highlightHeight})\n\t    \t  \t\t\t\t.style('pointer-events', 'all')\n\t    \t  \t\t\t\t.append(\"title\")\n\t    \t  \t\t\t\t.classed('knime-tooltip', true)\n\t    \t  \t\t\t\t.text(selectionTitle);\n\t\t  \t\t\t\t} \n\t  \t\t\t\t});\n\t  \t\t\t\tj = plotData[k].values.length;\n\t  \t\t\t\tk = plotData.length-1;\n\t\t  \t\t}\n\t  \t\t}\n\t  \t}\n    }\n    \n    function getClusterToRowMapping() {\n    \tvar map = {};\n    \tfor (var i = 0; i < _incomingTable.rows.length; i++) {\n    \t\tif(_incomingTable.rows[i].data[0]) {\n    \t\t\tmap[_incomingTable.rows[i].data[0]] = _incomingTable.rows[i].rowKey;\n    \t\t} else {\n    \t\t\tmap[\"Missing values\"] = _incomingTable.rows[i].rowKey;\n    \t\t}\n    \t}\n    \treturn map;\n    }\n    \n    // Helper class to handle conversion from cluster name to row key\n    function KeyNameMap(map) {\n\t\t   this.map = map;\n\t\t   this.reverseMap = {};\n\t\t   for(var key in map){\n\t\t      var value = map[key];\n\t\t      this.reverseMap[value] = key;   \n    \t}\n    }\n\t\t   \n\tKeyNameMap.prototype.getKeyFromName = function(name){ \n\t\treturn this.map[name]; \n\t}\n\tKeyNameMap.prototype.getNameFromKey = function(key){\n\t\treturn this.reverseMap[key];\n\t}\n    \n    function handleHighlightClick(event) {\n    \tif(!_value.options['selection']) {\n    \t\t_value.options['selection'] = [];\n    \t}\n    \tvar clusterName = event.x;\n    \tvar clusterKey = _keyNameMap.getKeyFromName(clusterName);\n    \tvar barIndex = getSelectedRowIDs().indexOf(clusterKey);\n    \t// Deselect already selected bar when clicking again on it\n    \tif(barIndex > -1 && (d3.event.ctrlKey || d3.event.shiftKey || d3.event.metaKey)){\n    \t\tif(_representation.options.enableSelection) {\n        \t\tif(_value.options.publishSelection) {\n        \t\t\tknimeService.removeRowsFromSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n        \t\t}\n    \t\t}\n\t\t\tremoveHilightBar(clusterName, false);\n\t\t\t_value.options['selection'].splice(barIndex, 1);\n    \t} else if(!d3.event.ctrlKey && !d3.event.shiftKey && !d3.event.metaKey) {\n    \t\t// Deselect all previously selected bars and select the newly clicked one\n    \t\tif(_representation.options.enableSelection) {\n        \t\tif(_value.options.publishSelection) {\n        \t\t\tknimeService.setSelectedRows(_translator.sourceID,[clusterKey], _translator.sourceID);\n        \t\t}\n    \t\t}\n\t\t\tremoveHilightBar(clusterName, true);\n    \t\tcreateHilightBar(clusterName, \"knime-selected\");\n    \t\t_value.options['selection'] = [];\n    \t\t_value.options['selection'].push([clusterKey, \"knime-selected\"]);\n    \t} else {\n    \t\t// Select the clicked bar, as it is either a new selection or a additional selection\n    \t\tif(_representation.options.enableSelection) {\n        \t\tif(_value.options.publishSelection) {\n        \t\t\tknimeService.addRowsToSelection(_translator.sourceID,[clusterKey], _translator.sourceID);\n        \t\t}\n    \t\t}\n    \t\tcreateHilightBar(clusterName, \"knime-selected\");\n    \t\t_value.options['selection'].push([clusterKey, \"knime-selected\"]);\n    \t}\n    \tcheckClearSelectionButton();\n    }\n    \n    function onSelectionChanged(data) {\n    \tif(!_value.options['selection']) {\n    \t\t_value.options['selection'] = [];\n    \t}\n    \tif (data.reevaluate) {\n    \t\tremoveHilightBar(\"\", true);\n    \t\tvar selectedRows = knimeService.getAllRowsForSelection(_translator.sourceID);\n    \t\tvar partiallySelectedRows = knimeService.getAllPartiallySelectedRows(_translator.sourceID);\n    \t\tfor (var selectedRow in selectedRows) {\n    \t\t\tvar length = _value.options['selection'].length;\n    \t\t\t_value.options['selection'][length] = [selectedRows[selectedRow], \"knime-selected\"];\n    \t\t\tcreateHilightBar(_keyNameMap.getNameFromKey(selectedRows[selectedRow]),\n    \t\t\t\t\t\"knime-selected\");\n    \t\t}\n    \t\tfor (var partiallySelectedRow in partiallySelectedRows) {\n    \t\t\tvar length = _value.options['selection'].length;\n    \t\t\t_value.options['selection'][length] = [partiallySelectedRows[partiallySelectedRow], \"knime-partially-selected\"];\n    \t\t\tcreateHilightBar(_keyNameMap.getNameFromKey(partiallySelectedRows[partiallySelectedRow]),\n    \t\t\t\t\t\"knime-partially-selected\");\n    \t\t}\n        } else if (data.changeSet) {\n        \tif (data.changeSet.removed) {\n        \t\tdata.changeSet.removed.map(function(rowId) {\n        \t\t\tvar clusterName = rowId;\n        \t\t\tvar index = getSelectedRowIDs().indexOf(clusterName);\n        \t\t\tif (index > -1) {\n        \t\t\t\tremoveHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n        \t\t\t\t_value.options['selection'].splice(index, 1);\n        \t\t\t}\n        \t\t});\n        \t}\n        \tif(data.changeSet.partialRemoved) {\n        \t\tdata.changeSet.partialRemoved.map(function(rowId) {\n        \t\t\tvar clusterName = rowId;\n        \t\t\tvar index = getSelectedRowIDs().indexOf(clusterName);\n        \t\t\tif (index > -1) {\n        \t\t\t\tremoveHilightBar(_keyNameMap.getNameFromKey(rowId), false);\n        \t\t\t\t_value.options['selection'].splice(index, 1);\n        \t\t\t}\n        \t\t});\n        \t}\n\t        if (data.changeSet.added) {\n\t            data.changeSet.added.map(function(rowId) {\n\t                var index = getSelectedRowIDs().indexOf(rowId);\n\t                if (index === -1) {\n\t                \t_value.options['selection'].push([rowId, \"knime-selected\"]);\n\t                \tcreateHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-selected\");\n\t                }\n\t            });\n\t        }\n\t        if(data.changeSet.partialAdded) {\n\t        \tdata.changeSet.partialAdded.map(function(rowId) {\n\t                var index = getSelectedRowIDs().indexOf(rowId);\n\t                if (index === -1) {\n\t                \t_value.options['selection'].push([rowId, \"knime-partially-selected\"]);\n\t                    createHilightBar(_keyNameMap.getNameFromKey(rowId), \"knime-partially-selected\");\n\t                }\n\t            });\n\t        }\n\t     }\n    \tcheckClearSelectionButton();\n    }\n\n\n    processData = function () {\n        var optMethod = _representation.options['aggr'];\n        var optFreqCol = _representation.options['freq'];\n        var optCat = _representation.options['cat'];\n\n        var customColors, colorScale;\n        if (_representation.inObjects[1]) {\n            // Custom color scale\n            var colorTable = new kt();\n            colorTable.setDataTable(_representation.inObjects[1]);\n            if (colorTable.getColumnTypes()[0] == 'string') {\n                customColors = {};\n                var colorCol = colorTable.getColumn(0);\n                for (var i = 0; i < colorCol.length; i++) {\n                    customColors[colorCol[i]] = colorTable.getRowColors()[i];\n                }\n                colorScale = [];\n            }\n        }\n\n        categories = knimeTable.getColumn(optCat);\n        var numCat = categories.length;\n\n        if (optMethod == 'Occurence\\u00A0Count') {\n            optFreqCol = [knimeTable.getColumnNames()[1]];\n        }\n\n        // Get the frequency columns\n        var valCols = [];\n        var isDuplicate = false;\n        freqCols = [];\n\n        for (var k = 0; k < optFreqCol.length; k++) {\n            var valCol = knimeTable.getColumn(optFreqCol[k]);\n            // ToDo: Add an isDuplicate test here...\n            if (isDuplicate != true) {\n                valCols.push(valCol);\n                freqCols.push(optFreqCol[k]);\n            }\n        }\n\n        plotData = [];\n        freqColValueOnMissValCat = [];\n        missValInCat = new Array(numCat);\n        for (var i = 0; i < numCat; i++) {\n            missValInCat[i] = [];\n        }\n        isMissValCat = false;\n        missValCatValues = [];\n        var numFreqColsNoMissVal = 0; // number of freq columns which have\n        // non-missing values (needed for color\n        // scale)\n        if (valCols.length > 0) {\n            var numDataPoints = valCols[0].length;\n            for (var j = 0; j < freqCols.length; j++) {\n\n                var col = freqCols[j];\n                if (optMethod == 'Occurence\\u00A0Count' && !_representation.isHistogram) {\n                    col = 'Occurrence Count';\n                }\n                var values = [];\n                var onlyMissValInCats = true; // whether the freq col has only\n                // missing values in\n                // non-\"Missing values\"\n                // categories\n                var hasValueOnMissValCat = false; // whether the freq col has\n                // a non-missing value in\n                // the Missing values\n                // category\n\n                for (var i = 0; i < numDataPoints; i++) {\n                    if (categories != undefined) {\n                        if (isDuplicate == true) {\n                            alert('Duplicate categories found in column.');\n                            return 'duplicate';\n                        }\n\n                        var cat = categories[i];\n                        var val = valCols[j][i];\n\n                        if (cat !== null) {\n                            if (val !== null) {\n                                // if both cat and value are not null - normal\n                                // case, just add the value\n                                onlyMissValInCats = false;\n                                values.push({\n                                    'x': cat,\n                                    'y': val\n                                });\n                            }\n                        } else {\n                            // Missing values category\n                            isMissValCat = true;\n                            if (val !== null) {\n                                // save the non-missing value for the\n                                // corresponding freq col\n                                missValCatValues.push({\n                                    'col': col,\n                                    'value': val\n                                });\n                                // this freq col has non-missing value in the\n                                // Missing value category\n                                hasValueOnMissValCat = true;\n                            }\n                        }\n\n                        if (val === null) {\n                            // this freq col has a missing value in the current\n                            // category - save this info\n                            missValInCat[i].push(col);\n                        }\n                    }\n                }\n\n                if (!onlyMissValInCats) {\n                    // the freq col has non-missing values in normal categories\n                    // - add this column to the view\n                    var plotStream = {\n                        'key': col,\n                        'values': values\n                    };\n                    plotData.push(plotStream);\n\n                    if (customColors) {\n                        var color = customColors[col];\n                        if (!color) {\n                            color = '#7C7C7C';\n                        }\n                        colorScale.push(color);\n                    }\n                    numFreqColsNoMissVal++;\n                } else {\n                    // The freq col has only missing values in normal categories\n                    // -\n                    // we save whether it has a non-missing value in the Missing\n                    // values category.\n                    // Whether this column is going to be displayed in the view\n                    // depends on the \"includeMissValCat\" option.\n                    // So we don't add the column to the plot at this moment -\n                    // wait for processMissingValues()\n                    // Note: a non-missing value (if there is) is stored in\n                    // missValCatValues - hence, enough to store only a boolean\n                    // flag\n                    freqColValueOnMissValCat.push({\n                        'col': col,\n                        'hasValueOnMissValCat': hasValueOnMissValCat\n                    });\n                    if (hasValueOnMissValCat) {\n                        // If there is a non-missing value, then the presence of\n                        // the column depends on the \"includeMissValCat\" option,\n                        // which can be switched in the view on the fly.\n                        // We do not want this switch to influence on the color\n                        // scale, so we count it\n                        numFreqColsNoMissVal++;\n                    }\n                }\n            }\n        } else {\n            if (hasNull == false) {\n                alert('No numeric columns detected.');\n                return 'numeric';\n            } else {\n                alert('Numeric columns detected, but contains missing values.');\n                return 'missing';\n            }\n        }\n\n        if (customColors) {\n            colorRange = colorScale;\n        } else {\n            // Default color scale\n            if (numFreqColsNoMissVal > 10) {\n                colorScale = d3.scale.category20();\n            } else {\n                colorScale = d3.scale.category10();\n            }\n            colorRange = colorScale.range();\n        }\n\n        processMissingValues();\n    };\n\n    /**\n\t * switched - if the chart update was triggered by changing the \"include\n\t * 'Missing values' category\" option in the view\n\t */\n    processMissingValues = function (switched) {\n        // Make a list of freq columns to exclude\n        var excludeCols = []; // column names to exclude\n        // Go through the list of those freq cols which have only missing values\n        // in normal categories\n        // and exclude those which either 1) has a missing value in the Missing\n        // values category, or\n        // 2) has a non-missing value there but the option is set to Don't\n        // include missing values\n        for (var i = 0; i < freqColValueOnMissValCat.length; i++) {\n            var col = freqColValueOnMissValCat[i];\n            if (!col.hasValueOnMissValCat || col.hasValueOnMissValCat && !_value.options.includeMissValCat) {\n                excludeCols.push(col.col);\n            }\n        }\n\n        // Make a list of excluded bars per category or whole categories\n        var excludeBars = []; // bars (in string representation) to exclude\n        var excludeCats = []; // category names to exclude\n        var numLeftCols = freqCols.length - excludeCols.length; // how many\n        // columns left\n        // after\n        // excluded ones\n        var missValCatBars; // bars for Missing values category we add to the\n        // end, so we store them separately\n        var excludeWholeMissValCat = false;\n        excludeFreqColCatMap = {};\n        // We group the warnings by category, so we iterate over categories\n        for (var i = 0; i < missValInCat.length; i++) {\n            var cat = categories[i];\n            // take only those freq cols which have missing values in the\n            // current category and were not whole excluded\n            var cols = missValInCat[i].filter(function (x) {\n                return excludeCols.indexOf(x) == -1;\n            });\n            if (cols.length > 0) {\n                if (cols.length == numLeftCols) {\n                    // if all the left freq cols have missing values - exclude\n                    // the whole category\n                    if (cat !== null) {\n                        excludeCats.push(cat);\n                    } else {\n                        excludeWholeMissValCat = true; // Missing values\n                        // category will be\n                        // appended to the end\n                    }\n                } else {\n                    // build a string of excluded bars (cat - col1, col2 ...)\n                    var label = cat !== null ? cat : MISSING_VALUES_LABEL;\n                    var str = label + ' - ' + cols.join(', ');\n                    if (cat !== null) {\n                        excludeBars.push(str);\n                    } else {\n                        missValCatBars = str; // Missing values category will\n                        // be appended to the end\n                    }\n                    // for normal categories and also for the Missing values\n                    // category (if it's included in the view)\n                    // we fill the map of excluded bars (grouped by freq cols) -\n                    // needed for Stacked plot\n                    if (cat !== null || _value.options.includeMissValCat) {\n                        cols.forEach(function (col) {\n                            if (excludeFreqColCatMap[col] != undefined) {\n                                excludeFreqColCatMap[col].push(cat);\n                            } else {\n                                excludeFreqColCatMap[col] = [cat];\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        // exclude smth from Missing values category, if it's included in the\n        // view\n        if (_value.options.includeMissValCat && _representation.options.reportOnMissingValues) {\n            if (excludeWholeMissValCat) {\n                excludeCats.push(MISSING_VALUES_LABEL);\n            } else if (missValCatBars !== undefined) {\n                excludeBars.push(missValCatBars);\n            }\n        }\n\n        // Add or remove the non-missing values of the Missing values category\n        for (var i = 0; i < missValCatValues.length; i++) {\n            var item = missValCatValues[i];\n            if (excludeCols.indexOf(item.col) != -1 && !(!_value.options.includeMissValCat && switched)) {\n                // Fact that the freq col is in missValCatValues means it has a\n                // non-missing value in Missing values category.\n                // If this col was excluded, that means it has only missing\n                // values in all other categories AND we \"don't include\n                // MissValCat\".\n                // In case it's the first time the plot is building, we don't\n                // need to do anything - call continue.\n                // But if a user switched the option \"includeMissValCat\" from\n                // 'on' to 'off', we need to remove the value of MissValCat from\n                // the plot further below.\n                continue;\n            }\n            // find if the plot has already the data (key->values) for the\n            // current freq col == key\n            var data = undefined;\n            var dataInd;\n            for (var j = 0; j < plotData.length; j++) { // many thanks to IE -\n                // we cannot use find()\n                // or findIndex() here\n                if (plotData[j].key == item.col) {\n                    data = plotData[j];\n                    dataInd = j;\n                    break;\n                }\n            }\n            if (_value.options.includeMissValCat && _representation.options.reportOnMissingValues) {\n                // if we include Missing values category to the view, we need to\n                // add its values\n                var val = {\n                    'x': MISSING_VALUES_LABEL,\n                    'y': item.value\n                };\n                if (data !== undefined) {\n                    data.values.push(val);\n                } else {\n                    plotData.push({\n                        'key': item.col,\n                        'values': [val]\n                    });\n                }\n            } else if (switched) {\n                // if we don't include Missing values category to the view AND\n                // this option was switched in the view, we need to remove its\n                // value\n                if (data !== undefined) {\n                    data.values.pop();\n                    if (data.values.length == 0) {\n                        plotData.splice(dataInd, 1);\n                    }\n                }\n            }\n        }\n\n        // Set warning messages\n        if (!showWarnings) {\n            return;\n        }\n        if (plotData.length == 0) {\n            // No data available warnings\n            var str;\n            if (missValCatValues.length != 0 && _representation.options.reportOnMissingValues) {\n                str = 'No chart was generated since all frequency columns have only missing values.\\nThere are values where the category name is missing.\\nTo see them switch on the option \"Include \\'Missing values\\' category\" in the view settings.';\n            } else {\n                str = 'No chart was generated since all frequency columns have only missing values or empty.\\nRe-run the workflow with different data.';\n            }\n            knimeService.setWarningMessage(str, NO_DATA_AVAILABLE);\n        } else {\n            knimeService.clearWarningMessage(NO_DATA_AVAILABLE);\n            // All other warnings\n            if (excludeCols.length > 0 && _representation.options.reportOnMissingValues) {\n                knimeService.setWarningMessage(\n                    'Following frequency columns are not present or contain only missing values and were excluded from the view:\\n    '\n\t\t\t\t\t+ excludeCols.join(', '), FREQ_COLUMN_MISSING_VALUES_ONLY);\n            } else {\n                knimeService.clearWarningMessage(FREQ_COLUMN_MISSING_VALUES_ONLY);\n            }\n\n            if (excludeCats.length > 0 && _representation.options.reportOnMissingValues) {\n                knimeService.setWarningMessage(\n                    'Following categories contain only missing values and were excluded from the view:\\n    '\n\t\t\t\t\t+ excludeCats.join(', '), CATEGORY_MISSING_VALUES_ONLY);\n            } else {\n                knimeService.clearWarningMessage(CATEGORY_MISSING_VALUES_ONLY);\n            }\n\n            if (excludeBars.length > 0 && _representation.options.reportOnMissingValues) {\n                knimeService.setWarningMessage(\n                    'Following bars contain only missing values in frequency column and were excluded from the view:\\n    '\n\t\t\t\t\t+ excludeBars.join('\\n    '), MISSING_VALUES_ONLY);\n            } else {\n                knimeService.clearWarningMessage(MISSING_VALUES_ONLY);\n            }\n        }\n    };\n\n    /**\n\t * This is a workaround for the stacked plot problem coming from the nvd3\n\t * library implementation. They do not really support missing values in the\n\t * Stacked option: (https://github.com/novus/nvd3/issues/1941 - \"The\n\t * solution is to adjust your data before handing it to nvd3.\" - nice\n\t * answer) The implementation uses a simple d3.layout.stack which requires\n\t * all data have the same length\n\t * (https://github.com/d3/d3-3.x-api-reference/blob/master/Stack-Layout.md#_stack)\n\t * Missing values may lead to different lengths. A workaround here is to add\n\t * dummy null values in place of excluded bars before drawing to Stacked\n\t * plot. And remove them before switching to Grouped plot.\n\t */\n    fixStackedData = function (addDummy) {\n        plotData.forEach(function (dataValues) {\n            var excludeCats = excludeFreqColCatMap[dataValues.key];\n            if (excludeCats == undefined) {\n                // if this freq col does not have excluded bars at all - nothing\n                // to do\n                return;\n            }\n            if (addDummy) {\n                // Another implementation thing is that the categories in every\n                // freq col must follow the same order.\n                // So we cannot simply append dummy nulls to the end.\n                // Instead we need to replace the whole \"values\" array.\n                // We go over the categories and add either a real value or a\n                // dummy null depending on what's present.\n                var i = 0, j = 0;\n                var values = dataValues.values;\n                var newValues = [];\n                categories.forEach(function (cat) {\n                    if (cat == null) {\n                        return;\n                    }\n                    if (i < values.length && values[i].x == cat) {\n                        newValues.push(values[i]);\n                        i++;\n                    } else if (j < excludeCats.length && excludeCats[j] == cat) {\n                        newValues.push({\n                            'x': cat,\n                            'y': null\n                        });\n                        j++;\n                    }\n                });\n                if (i < values.length && values[i].x == MISSING_VALUES_LABEL) {\n                    newValues.push(values[i]);\n                } else if (j < excludeCats.length && excludeCats[j] == null) {\n                    newValues.push({\n                        'x': MISSING_VALUES_LABEL,\n                        'y': null\n                    });\n                }\n                dataValues.values = newValues;\n            } else {\n                // remove dummy null values (basically any null values as there\n                // can be no other nulls)\n                dataValues.values = dataValues.values.filter(function (value) {\n                    return value.y !== null;\n                });\n            }\n        });\n    };\n\n    function updateTitles(updateChart) {\n        if (chart) {\n            var curTitle = d3.select('#title');\n            var curSubtitle = d3.select('#subtitle');\n            var chartNeedsUpdating = curTitle.empty() != !(_value.options.title)\n\t\t\t\t|| curSubtitle.empty() != !(_value.options.subtitle);\n            if (!_value.options.title) {\n                curTitle.remove();\n            }\n            if (_value.options.title) {\n                if (curTitle.empty()) {\n                    svg.append('text')\n                        .attr('x', 20)\n                        .attr('y', 30)\n                        .attr('id', 'title')\n                        .attr('class', 'knime-title')\n                        .text(_value.options.title);\n                } else {\n                    curTitle.text(_value.options.title);\n                }\n            }\n            if (!_value.options.subtitle) {\n                curSubtitle.remove();\n            }\n            if (_value.options.subtitle) {\n                if (curSubtitle.empty()) {\n                    svg.append('text')\n                        .attr('x', 20)\n                        .attr('y', _value.options.title ? 46 : 20)\n                        .attr('id', 'subtitle')\n                        .attr('class', 'knime-subtitle')\n                        .text(_value.options.subtitle);\n                } else {\n                    curSubtitle.text(_value.options.subtitle).attr('y', _value.options.title ? 46 : 20);\n                }\n            }\n\n            var topMargin = 10;\n            topMargin += _value.options.title ? 10 : 0;\n            topMargin += _value.options.subtitle ? 8 : 0;\n            if (_representation.options['legend']) {\n                chart.legend.margin({\n                    top : topMargin,\n                    bottom : topMargin\n                });\n            } else {\n                chart.margin({\n                    top : topMargin * 2\n                });\n            }\n\n            var isTitle = _value.options.title || _value.options.subtitle;\n            knimeService.floatingHeader(isTitle);\n\n            if (updateChart && chartNeedsUpdating) {\n                if (_representation.options.svg.fullscreen && _representation.runningInView) {\n                    var height = (isTitle) ? '100%' : 'calc(100% - ' + knimeService.headerHeight() + 'px)';\n                    layoutContainer.style('height', height)\n                    // two rows below force to invalidate the container which\n                    // solves a weird problem with vertical scroll bar in IE\n                        .style('display', 'none')\n                        .style('display', 'block');\n                    d3.select('#svgContainer').style('height', height);\n                }\n                chart.update();\n            }\n        }\n    }\n\n    /**\n\t * Updates the axis labels after they have been wrapped. And add a title to\n\t * show the full name. Additionally adjust the length of the maximum and\n\t * minimum value on the y-axis.\n\t */\n    function updateLabels() {\n        var optShowMaximum = _value.options.showMaximum;\n        if (typeof optShowMaximum == 'undefined') {\n            optShowMaximum = _representation.options.showMaximum;\n        }\n        var optOrientation = _value.options['orientation'];\n        var texts = svg.select('.knime-x').selectAll('text');\n        texts.each(function (d, i) {\n            if (typeof wrapedPlotData[0].values[i] !== 'undefined') {\n                var self = d3.select(this);\n                self.text(wrapedPlotData[0].values[i].x);\n                self.append('title').classed('knime-tooltip', true);\n            }\n        });\n        var stacked = _value.options['chartType'];\n        var extremValues = [];\n    \tif(stacked == \"Grouped\") {\n    \t\textremValues = getRoundedMaxValue(false);\t\n    \t} else {\n    \t\textremValues = getRoundedMaxValue(true);\n    \t}\n    \tvar minValue = extremValues[0];\n    \tvar maxValue = extremValues[1];\n    \t\n        var tickAmount = chart.yAxis.ticks();\n        if (tickAmount < 2) {\n            tickAmount = 2;\n        }\n\n        var scale = d3.scale.linear().domain([minValue, maxValue]);\n\n        var textsYMin, textsYMax;\n        if (optShowMaximum) {\n            if (optOrientation) {\n                textsYMin = svg.select('.nv-axisMin-x').selectAll('text');\n                textsYMax = svg.select('.nv-axisMax-x').selectAll('text');\n            } else {\n                textsYMin = svg.select('.nv-axisMin-y').selectAll('text');\n                textsYMax = svg.select('.nv-axisMax-y').selectAll('text');\n            }\n            textsYMin.text(minValue);\n            textsYMax.text(maxValue);\n        }\n\n        var labelTooltip = texts.selectAll('.knime-tooltip');\n        var counter = 0;\n        labelTooltip.each(function (d, i) {\n            var self = d3.select(this);\n            if (typeof plotData[0].values[counter] !== 'undefined') {\n                self.text(plotData[0].values[counter].x);\n            }\n            counter++;\n        });\n\n        // Create titles for the Axis-Tooltips\n        svg.select('.knime-y text.knime-axis-label').append('title').classed('knime-tooltip', true).text(\n            _value.options['freqLabel']);\n        svg.select('.knime-x text.knime-axis-label').append('title').classed('knime-tooltip', true).text(\n            _value.options['catLabel']);\n    }\n    \n    function getRoundedMaxValue(isStacked) {\n     \tvar maxValue = 0;\n     \tvar minValue = 0;\n     \tvar considerNegativeList = false;\n     \tif(isStacked) {\n        \tvar sumListPositive = [];\n        \tvar sumListNegative = [];\n\t        for (var i = 0; i < plotData.length; i++) {\n\t        \tfor (var j = 0; j < plotData[i].values.length; j++) { \n\t\t        \tif(sumListPositive.length < plotData[i].values.length) {\n\t\t        \t\tsumListPositive.push(0);\n\t\t        \t\tsumListNegative.push(0);\n\t\t        \t} \n\t        \t\tif(plotData[i].disabled !== true) {\n\t        \t\t\tif(plotData[i].values[j].y>0) {\n\t        \t\t\t\tsumListPositive[j] += plotData[i].values[j].y;\n\t        \t\t\t} else {\n\t        \t\t\t\tsumListNegative[j] += plotData[i].values[j].y;\n\t        \t\t\t\tconsiderNegativeList = true;\n\t        \t\t\t}\n\t        \t\t} \n\t        \t}\n\t        }\n\t        maxValue = d3.max(sumListPositive);\n\t        if(considerNegativeList) {\n\t        \tminValue = d3.min(sumListNegative);\n\t        }\n     \t} else {\n\t        for (var i = 0; i < plotData.length; i++) {\n\t        \tif(plotData[i].disabled !== true) {\n\t\t            var tempMaxValue = Math.max(d3.max(plotData[i].values, function (d) {\n\t\t                return parseFloat(d.y);\n\t\t            }), 0);\n\t\t            if(tempMaxValue > maxValue) {maxValue = tempMaxValue;}\n\t\t            var tempMinValue = Math.min(d3.min(plotData[i].values, function (d) {\n\t\t                return parseFloat(d.y);\n\t\t            }), 0);\n\t\t            if(tempMinValue < minValue) {minValue = tempMinValue;}\n\t        \t}\n\t        }\n     \t}\n     \t\n        var tickAmount = chart.yAxis.ticks();\n        if (tickAmount < 2) {\n        \ttickAmount = 2;\n        }\n\n        var scale = d3.scale.linear().domain([minValue, maxValue]);\n    \tvar ticks = scale.ticks(tickAmount);\n    \tvar precision = 1;\n    \tfor (var i = 0; i < ticks.length; i++) {\n            if (ticks[i] !== 0) {\n                var curTick = ticks[i];\n                if (curTick.toString().indexOf('.') >= 0) {\n                    // +1 because the precision of the maximum should be one\n                    // decimal more then the normal ticks\n                    precision = Math.max((curTick.toString().split('.')[1].length) + 1, precision);\n                } else if (curTick.toString().indexOf('e') >= 0) {\n                    precision = Math.max(Math.abs(parseFloat(curTick.toString().split('e')[1])), precision);\n                }\n            }\n        }\n    \t\n    \tvar roundedMaxValue = Math.ceil(parseFloat(maxValue) * Math.pow(10, precision)) / Math.pow(10, precision);\n    \tvar roundedMinValue = Math.floor(parseFloat(minValue) * Math.pow(10, precision)) / Math.pow(10, precision);\n    \treturn [roundedMinValue,roundedMaxValue];\n    }\n\n    /**\n\t * Find the max size of one element on the y-axis to see how much space is\n\t * needed. To find out the max size, a temp-text object is created and\n\t * measured. Afterwards that temp-text is deleted (is not visible in the\n\t * view).\n\t */\n    function checkMaxSizeYAxis(number, optShowMaximum) {\n    \tvar maxValue = 0, minValue = 0;\n    \tvar extremValues = [];\n    \tvar stacked = _value.options['chartType'];\n    \tif(stacked == \"Grouped\") {\n    \t\textremValues = getRoundedMaxValue(false);\t\n    \t} else {\n    \t\textremValues = getRoundedMaxValue(true);\n    \t}\n    \tminValue = extremValues[0];\n    \tmaxValue = extremValues[1];\n       \n        var svgHeight = parseInt(d3.select('svg').style('height'));\n        var svgWidth = parseInt(d3.select('svg').style('width'));\n\n        // Calculate values of the y-axis to get an impression about the\n        // precision.\n        var scale = d3.scale.linear().domain([minValue, maxValue]).range(\n            [0, _representation.options['svg']['height']]);\n        var ticks = scale.ticks(4);\n        if (optShowMaximum) {\n            if (maxValue.toString().indexOf('.') > 0 ) {\n            \tif(ticks[ticks.length-1].toString().indexOf('.') > 0) {\n            \t\tvar decimalString = ticks[ticks.length - 1].toString().split('.')[1];\n            \t\tticks.push(parseFloat((maxValue.toFixed(decimalString.length)+1)));            \t\t\n            \t} else {\n            \t\tticks.push(parseFloat(maxValue.toFixed(0)));\n            \t}\n            } else {\n                ticks.push(maxValue);\n            }\n            if (minValue < 0 && minValue.toString().indexOf('e') < 0) {\n            \tif(ticks[0].toString().split('.')[1]) {\n            \t\tticks.push((minValue.toFixed(ticks[0].toString().split('.')[1].length - 1)));\n            \t} else {\n            \t\tticks.push((minValue.toFixed(1)));\n            \t}\n            } else if (minValue < 0) {\n                ticks.push(minValue);\n            }\n        }\n        var configObject = {\n            container: document.querySelector('svg'),\n            tempContainerClasses: 'knime-axis',\n            maxWidth: svgWidth,\n            maxHeight: svgHeight * 0.1,\n        };\n\n        var results = knimeService.measureAndTruncate(ticks, configObject);\n\n        // Return the format to show the result and the space needed to the left\n        // border.\n        return results;\n    }\n\n    /**\n\t * Find the max size of the biggest element on the x-Axis. Move the Graph so\n\t * that this object is completely visible.\n\t */\n    function checkMaxSizeXAxis(number, staggerLabels) {\n        var optOrientation = _value.options['orientation'];\n        var svgHeight = parseInt(d3.select('svg').style('height'));\n        var svgWidth = parseInt(d3.select('svg').style('width'));\n        var amountOfBars = number[0].values.length;\n        var amountOfDimensions = number.length;\n        \n        var spaceBetweenBars = _representation.isHistogram ? 0 : 40; \n        var maxWidth;\n        if(optOrientation) {\n        \tmaxWidth = 0.5 * svgWidth;\n        } else {\n        \tvar barWidth;\n        \tif((d3.select(\".nv-groups\").node()) !== null) {\n        \t\tbarWidth = d3.select(\".nv-groups\").select(\"rect\")[0][0].width.baseVal.value * amountOfDimensions;\n        \t} else {\n        \t\tbarWidth = (svgWidth / amountOfBars) - spaceBetweenBars\n        \t}\n        \tif(staggerLabels) {\n        \t\tmaxWidth = barWidth * 2;\n        \t} else {\n        \t\tmaxWidth = barWidth;\n        \t}\n        }\n\n        var configObject = {\n            container: document.querySelector('svg'),\n            tempContainerClasses: 'knime-axis',\n            maxWidth: _representation.isHistogram ? undefined : maxWidth,\n            /*maxHeight: svgHeight / amountOfBars,*/\n            minimalChars: 1,\n        };\n        var xValues = [];\n        for (var value in number[0].values) {\n            xValues.push(number[0].values[value].x);\n        }\n\n        var results = knimeService.measureAndTruncate(xValues, configObject);\n        \n        var xExtremValues = [];\n        xExtremValues.push(number[0].values[0].x);\n        xExtremValues.push(number[0].values[number[0].values.length-1].x);\n        \n        if(staggerLabels) {\n        \tif(!optOrientation) {\n    \t\t\tconfigObject.maxWidth = (svgWidth / amountOfBars) - spaceBetweenBars;\n        \t} \n        }\n        var extremResults = knimeService.measureAndTruncate(xExtremValues, configObject);\n\n        // Update the cloned data array to contain the wrapped labels\n        for (var group in number) {\n            for (var value in number[group].values) {\n            \tif(value == 0) {\n            \t\twrapedPlotData[group].values[value].x = extremResults.values[0].truncated;\n            \t} else if(value == number[group].values.length-1) {\n            \t\twrapedPlotData[group].values[value].x = extremResults.values[1].truncated;\n            \t} else {\n            \t    var val = results.values[parseInt(value)];\n            \t    wrapedPlotData[group].values[value].x = typeof val === 'undefined' ? null : val.truncated;\n            \t}\n            }\n        }\n        return results;\n    }\n\n    function updateAxisLabels(updateChart) {\n\n        if (chart) {\n            var optOrientation = _value.options['orientation'];\n            var optStaggerLabels = _value.options['staggerLabels'];\n            var stacked = _value.options['chartType'];\n            var optShowMaximum = _value.options.showMaximum;\n            var curCatAxisLabel, curFreqAxisLabel;\n            var curCatAxisLabelElement = d3.select('.nv-x.nv-axis .nv-axis-label');\n            var curFreqAxisLabelElement = d3.select('.nv-y.nv-axis .nv-axis-label');\n            var freqLabel = _value.options['freqLabel'];\n            var catLabel = _value.options['catLabel'];\n            var svgHeight = parseInt(d3.select('svg').style('height'));\n            var svgWidth = parseInt(d3.select('svg').style('width'));\n\n            if (typeof optShowMaximum == 'undefined') {\n                optShowMaximum = _representation.options.showMaximum;\n            }\n\n            wrapedPlotData = JSON.parse(JSON.stringify(plotData));\n\n            if (!curCatAxisLabelElement.empty()) {\n                curCatAxisLabel = curCatAxisLabelElement.text();\n            }\n\n            if (!curFreqAxisLabelElement.empty()) {\n                curFreqAxisLabel = curCatAxisLabelElement.text();\n            }\n\n            var chartNeedsUpdating = curCatAxisLabel != _value.options.catLabel\n\t\t\t\t|| curFreqAxisLabel != _value.options.freqLabel;\n            if (!chartNeedsUpdating)\n                return;\n\n            var configObject = {\n                container: document.querySelector('svg'),\n                tempContainerClasses: 'knime-axis',\n                maxWidth: svgWidth * 0.5,\n                maxHeight: svgHeight * 0.5,\n                minimalChars: 1,\n            };\n            optOrientation ? configObject.tempContainerAttributes = { transform: 'rotate(-90)' }\n                : configObject.tempContainerAttributes = '';\n            var catLabelSize = knimeService.measureAndTruncate(catLabel ? [catLabel] : [''], configObject);\n            optOrientation ? configObject.tempContainerAttributes.transform = ''\n                : configObject.tempContainerAttributes = { transform: 'rotate(-90)' };\n            var freqLabelSize = knimeService.measureAndTruncate(freqLabel ? [freqLabel] : [''], configObject);\n\n            var maxSizeYAxis = checkMaxSizeYAxis(wrapedPlotData, optShowMaximum);\n            var maxSizeXAxis = checkMaxSizeXAxis(wrapedPlotData, optStaggerLabels);\n            var svgSize = optOrientation ? parseInt(d3.select('svg').style('width')) : parseInt(d3.select('svg').style(\n                'height'));\n\n            freqLabel = freqLabelSize.values[0].truncated;\n            catLabel = catLabelSize.values[0].truncated;\n            \n            // space between two labels\n            var distanceBetweenLabels = 150;\n            if (optOrientation) {\n            \tvar tickAmount = parseInt((svgSize - maxSizeXAxis.max.maxWidth) / (maxSizeYAxis.max.maxWidth + distanceBetweenLabels));\n                if (optShowMaximum) {\n                \t// extend the border of the svg to be able to see the complete maximum label \n                \t// factor 0.6 is chosen to give the label a little space to the border\n                \tvar rightMargin = 0.6 * maxSizeYAxis.max.maxWidth;\n                }\n            } else {\n            \tvar tickAmount = parseInt((svgSize - maxSizeYAxis.max.maxHeight) / (maxSizeYAxis.max.maxHeight + distanceBetweenLabels));\n            }\n            \n            // nvd3 sets the cat label 55 pixel away from the axis. As with changing font size this\n            // is not enough, it is easier to calculate it ourselves\n            var spacingCatLabel = 55;\n            \n            // nvd3 sets the freq label 20 pixel away from the axis. As with changing font size this\n            // is not enough, it is easier to calculate it ourselves\n            var spacingFreqLabel = 20;\n            \n            // add some empty space, so that two labels are not to close together\n            var additionalEmptySpace = 15;\n\n            var paddingAmount = 15;\n            chart.xAxis\n                .axisLabel(catLabel)\n                .axisLabelDistance(optOrientation ? maxSizeXAxis.max.maxWidth - spacingCatLabel + additionalEmptySpace + paddingAmount\n                \t\t: optStaggerLabels ? maxSizeXAxis.max.maxHeight*2 -spacingCatLabel + additionalEmptySpace *2 + paddingAmount\n                \t\t: -spacingFreqLabel + maxSizeXAxis.max.maxHeight * 1.5)\n                .tickPadding(paddingAmount)\n                .showMaxMin(false);\n\n            chart.yAxis.axisLabel(freqLabel)\n                .axisLabelDistance(optOrientation ? -spacingFreqLabel + maxSizeYAxis.max.maxHeight\n                \t\t: (maxSizeYAxis.max.maxWidth - spacingCatLabel + additionalEmptySpace))\n                .showMaxMin(optShowMaximum)\n                .ticks(tickAmount)\n                .tickFormat(d3.format('~.g'));\n            \n            var extremValues = [];\n        \tif(stacked == \"Grouped\") {\n        \t\textremValues = getRoundedMaxValue(false);\n        \t} else {\n        \t\textremValues = getRoundedMaxValue(true);\n        \t}\n        \tchart.yDomain([extremValues[0],extremValues[1]]);\n            \n        \tvar bottomMargin = optOrientation ? maxSizeYAxis.max.maxHeight + freqLabelSize.max.maxHeight + additionalEmptySpace\n        \t\t\t: maxSizeXAxis.max.maxHeight + catLabelSize.max.maxHeight + additionalEmptySpace;\n        \tvar leftMargin = optOrientation ? maxSizeXAxis.max.maxWidth + catLabelSize.max.maxWidth + additionalEmptySpace + paddingAmount\n        \t\t\t: maxSizeYAxis.max.maxWidth + freqLabelSize.max.maxWidth + additionalEmptySpace;\n        \t\n            if (!_value.options.catLabel) {\n                bottomMargin = optOrientation ? bottomMargin\n                \t\t: maxSizeXAxis.max.maxHeight + additionalEmptySpace;\n                leftMargin = optOrientation ? leftMargin : maxSizeYAxis.max.maxWidth\n                \t\t+ freqLabelSize.max.maxWidth + additionalEmptySpace;\n            }\n            if (!_value.options.freqLabel) {\n            \tbottomMargin = optOrientation ? maxSizeXAxis.max.maxHeight + additionalEmptySpace : bottomMargin;\n                leftMargin = optOrientation ? leftMargin + paddingAmount\n                \t\t: maxSizeYAxis.max.maxWidth + additionalEmptySpace;\n            }\n            if (!optOrientation) {\n                chart.staggerLabels(optStaggerLabels);\n                if (optStaggerLabels) {\n                \tbottomMargin += _value.options.catLabel ? 0.25 *maxSizeXAxis.max.maxHeight + paddingAmount\n                        : 0.5 * maxSizeXAxis.max.maxHeight + paddingAmount;\n                }\n            }\n            chart.margin({\n                left: leftMargin,\n                bottom: bottomMargin,\n                right: rightMargin\n            });\n\n            if (updateChart) {\n                chart.update();\n            }\n        }\n    }\n\n    function updateChartType() {\n        if (this.value != _value.options.chartType) {\n            _value.options.chartType = this.value;\n            var stacked = this.value == 'Stacked';\n            fixStackedData(stacked);\n            chart.stacked(stacked);\n            drawChart(true);\n        }\n    }\n\n    drawControls = function () {\n        if (!knimeService) {\n            return;\n        }\n\n        if (_representation.options.displayFullscreenButton) {\n            knimeService.allowFullscreen();\n        }\n\n        if (!_representation.options.enableViewControls)\n            return;\n\n        var titleEdit = _representation.options.enableTitleEdit;\n        var subtitleEdit = _representation.options.enableSubtitleEdit;\n        var axisEdit = _representation.options.enableAxisEdit;\n        var chartTypeEdit = _representation.options.enableStackedEdit;\n        var orientationEdit = _representation.options.enableHorizontalToggle;\n        var staggerLabels = _representation.options.enableStaggerToggle;\n        var switchMissValCat = _representation.options.enableSwitchMissValCat;\n        var showMaximum = _representation.options.enableMaximumValue;\n        var enableSelection = _representation.options.enableSelection;\n        var displayClearButton = _representation.options.displayClearSelectionButton;\n\n        if (titleEdit || subtitleEdit) {\n            if (titleEdit) {\n                var chartTitleText = knimeService.createMenuTextField('chartTitleText', _value.options.title,\n                    function () {\n                        if (_value.options.title != this.value) {\n                            _value.options.title = this.value;\n                            updateTitles(true);\n                        }\n                    }, true);\n                knimeService.addMenuItem('Chart Title:', 'header', chartTitleText);\n            }\n            if (subtitleEdit) {\n                var chartSubtitleText = knimeService.createMenuTextField('chartSubtitleText', _value.options.subtitle,\n                    function () {\n                        if (_value.options.subtitle != this.value) {\n                            _value.options.subtitle = this.value;\n                            updateTitles(true);\n                        }\n                    }, true);\n                var mi = knimeService.addMenuItem('Chart Subtitle:', 'header', chartSubtitleText, null,\n                    knimeService.SMALL_ICON);\n            }\n            if (axisEdit || orientationEdit || staggerLabels) {\n                knimeService.addMenuDivider();\n            }\n        }\n\n        if (axisEdit) {\n            var catAxisText = knimeService.createMenuTextField('catAxisText', _value.options.catLabel, function () {\n                _value.options.catLabel = this.value;\n                updateAxisLabels(true);\n            }, true);\n            knimeService.addMenuItem('Category axis label:', 'ellipsis-h', catAxisText);\n\n            var freqAxisText = knimeService.createMenuTextField('freqAxisText', _value.options.freqLabel, function () {\n                _value.options.freqLabel = this.value;\n                updateAxisLabels(true);\n            }, true);\n            knimeService.addMenuItem('Frequency axis label:', 'ellipsis-v', freqAxisText);\n\n            if (switchMissValCat || orientationEdit || staggerLabels || chartTypeEdit) {\n                knimeService.addMenuDivider();\n            }\n        }\n\n        if (switchMissValCat && isMissValCat && _representation.options.reportOnMissingValues) {\n            var switchMissValCatCbx = knimeService.createMenuCheckbox('switchMissValCatCbx',\n                _value.options.includeMissValCat, function () {\n                    if (_value.options.includeMissValCat != this.checked) {\n                        _value.options.includeMissValCat = this.checked;\n                        var stacked = _value.options.chartType == 'Stacked';\n                        if (stacked) {\n                            fixStackedData(false);\n                        }\n                        processMissingValues(true);\n                        if (stacked) {\n                            fixStackedData(true);\n                        }\n                        chart.update();\n                    }\n                });\n            knimeService.addMenuItem('Include \\'Missing values\\' category: ', 'question', switchMissValCatCbx);\n\n            if (orientationEdit || staggerLabels || chartTypeEdit) {\n                knimeService.addMenuDivider();\n            }\n        }\n\n        if (chartTypeEdit) {\n            var groupedRadio = knimeService.createMenuRadioButton('groupedRadio', 'chartType', 'Grouped',\n                updateChartType);\n            groupedRadio.checked = (_value.options.chartType == groupedRadio.value);\n            knimeService.addMenuItem('Grouped:', 'align-left fa-rotate-270', groupedRadio);\n\n            var stackedRadio = knimeService.createMenuRadioButton('stackedRadio', 'chartType', 'Stacked',\n                updateChartType);\n            stackedRadio.checked = (_value.options.chartType == stackedRadio.value);\n            knimeService.addMenuItem('Stacked:', 'tasks fa-rotate-270', stackedRadio);\n\n            if (orientationEdit || staggerLabels) {\n                knimeService.addMenuDivider();\n            }\n        }\n\n        if (orientationEdit) {\n            var orientationCbx = knimeService.createMenuCheckbox('orientationCbx', _value.options.orientation,\n                function () {\n                    if (_value.options.orientation != this.checked) {\n                        _value.options.orientation = this.checked;\n                        d3.select('#staggerCbx').property('disabled', this.checked);\n                        drawChart(true);\n                    }\n                });\n            knimeService.addMenuItem('Plot horizontal bar chart:', 'align-left', orientationCbx);\n        }\n\n        if (staggerLabels) {\n            var staggerCbx = knimeService.createMenuCheckbox('staggerCbx', _value.options.staggerLabels, function () {\n                if (_value.options.staggerLabels != this.checked) {\n                    _value.options.staggerLabels = this.checked;\n                    drawChart(true);\n                }\n            });\n            staggerCbx.disabled = _value.options.orientation;\n            knimeService.addMenuItem('Stagger labels:', 'map-o', staggerCbx);\n        }\n\n        if (showMaximum) {\n            var displayMaximumCbx = knimeService.createMenuCheckbox('displayMaximumCbx', _value.options.showMaximum,\n                function () {\n                    if (_value.options.showMaximum != this.checked) {\n                        _value.options.showMaximum = this.checked;\n                        drawChart(true);\n                    }\n                });\n            knimeService.addMenuItem('Display maximum value:', 'arrows-v', displayMaximumCbx);\n        }\n        \n        if (enableSelection) {\n        \tknimeService.addMenuDivider();\n        \tvar subscribeToSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-double-right', 'faded right sm', 'left bold');\n        \tvar subscribeToSelectionMenu = knimeService.createMenuCheckbox('subscribeToSelection', \n        \t\t\t_value.options.subscribeToSelection, function () {\n        \t\tif (_value.options.subscribeToSelection != this.checked) {\n        \t\t\t_value.options.subscribeToSelection = this.checked;\n        \t\t\tsubscribeToSelection(_value.options.subscribeToSelection);\n        \t\t}\n        \t});\n        \tknimeService.addMenuItem('Subscribe to selection:', subscribeToSelectionIcon, subscribeToSelectionMenu);\n        \t\n        \tvar publishSelectionIcon = knimeService.createStackedIcon('check-square-o', 'angle-right', 'faded left sm', 'right bold');\n            var publishSelectionMenu = knimeService.createMenuCheckbox('publishSelection', _value.options.publishSelection,\n                function () {\n                    if (_value.options.publishSelection != this.checked) {\n                        _value.options.publishSelection = this.checked;\n                        publishSelection(this.checked);\n                    }\n                });\n            knimeService.addMenuItem('Publish selection:', publishSelectionIcon, publishSelectionMenu);\n        }\n        \n        if (displayClearButton &&  _representation.options.enableSelection) {\n\t\t\tknimeService.addButton(\"clearSelectionButton\", \"minus-square-o\", \"Clear selection\", function(){\n\t\t\t\td3.selectAll(\".row\").classed({\"selected\": false, \"knime-selected\": false, \"unselected\": false });\n\t\t\t\tremoveHilightBar(\"\",true);\n\t\t\t\t_value.options['selection'] = [];\n\t\t\t\tpublishSelection(true);\n\t\t\t});\n\t\t\td3.select(\"#clearSelectionButton\").classed(\"inactive\", true);\n\t\t}\n    };\n\n    function setCssClasses() {\n        // axis\n        var axis = d3.selectAll('.nv-axis')\n            .classed('knime-axis', true);\n        d3.selectAll('.nv-x')\n            .classed('knime-x', true);\n        d3.selectAll('.nv-y')\n            .classed('knime-y', true);\n        d3.selectAll('.nv-axislabel')\n            .classed('knime-axis-label', true);\n        axis.selectAll('path.domain')\n            .classed('knime-axis-line', true);\n        var axisMaxMin = d3.selectAll('.nv-axisMaxMin')\n            .classed('knime-axis-max-min', true);\n        axisMaxMin.selectAll('text')\n            .classed('knime-tick-label', true);\n        var tick = axis.selectAll('.knime-axis .tick')\n            .classed('knime-tick', true);\n        tick.selectAll('text')\n            .classed('knime-tick-label', true);\n        tick.selectAll('line')\n            .classed('knime-tick-line', true);\n\n        // legend\n        d3.selectAll('.nv-legendWrap')\n            .classed('knime-legend', true);\n        d3.selectAll('.nv-legend-symbol')\n            .classed('knime-legend-symbol', true);\n        d3.selectAll('.nv-legend-text')\n            .classed('knime-legend-label', true);\n\n        // Tooltip for axis labels allows to receive all mouse events\n        var axisToolTip = svg.selectAll('.knime-tick-label');\n        var labelToolTip = svg.selectAll('.knime-axis-label');\n        axisToolTip.style('pointer-events', 'all');\n        labelToolTip.style('pointer-events', 'all');\n        updateLabels();\n        if(_representation.options['enableSelection']) {\n        \tregisterClickHandler();\n        }\n    }\n\n    function setTooltipCssClasses() {\n        // tooltip\n        var tooltip = d3.selectAll('.nvtooltip')\n            .classed('knime-tooltip', true);\n        tooltip.selectAll('.x-value')\n            .classed('knime-tooltip-caption', true)\n            .classed('knime-x', true);\n        tooltip.selectAll('.legend-color-guide')\n            .classed('knime-tooltip-color', true);\n        tooltip.selectAll('.key')\n            .classed('knime-tooltip-key', true);\n        tooltip.selectAll('.value')\n            .classed('knime-tooltip-value', true);\n\n    }\n\n    barchart.validate = function () {\n        return true;\n    };\n\n    barchart.getComponentValue = function () {\n        return _value;\n    };\n\n    barchart.getSVG = function () {\n        var svgElement = d3.select('svg')[0][0];\n        knimeService.inlineSvgStyles(svgElement);\n\n        // Return the SVG as a string.\n        return (new XMLSerializer()).serializeToString(svgElement);\n    };\n\n    return barchart;\n}());"],"cssCode":["/* make sure colors on bars are correct (inherit from group) */\nsvg.colored .nvd3 .nv-multibar .nv-groups rect, \nsvg.colored .nvd3 .nv-multibarHorizontal .nv-groups rect, \nsvg.colored .nvd3 .nv-discretebar .nv-groups rect {\n\tfill: inherit !important;\n\tstroke: inherit !important;\n}\n\ntext.knime-tick-label.knime-selected {\n\tfont-weight: bold;\n}\nrect.knime-selected {\n\tfill: orange;\n\t\n}\nrect.knime-partially-selected {\n\tfill: grey;\n}\ntext.knime-tick-label.knime-partially-selected {\n\tfont-weight: bold;\n}\n\nrect.nv-bar.positive {\n\tcursor:pointer;\n}\n\n/* don't display the maximum grid line if present on vertical bar chart */\n/*.nv-multiBarWithLegend .knime-axis.knime-y g.tick.knime-tick:nth-last-child(3) line {\n    display: none;\n}*/"],"flowVariables":{"knime.workspace":"C:\\Users\\mehar\\knime-workspace","css-stylesheet":"/* example style rule */\n.knime-title {\n\tfont-size: 26px;\n\ttext-align: center;\n\tmargin-bottom: 8px;\n}\n\n.knime-subtitle {\n\ttext-align: center;\n\tfont-size: 12px; \n}\n\n"}},"nodeInfo":{"@class":"org.knime.js.core.JSONWebNodeInfo","nodeAnnotation":"","nodeWarnMessage":null,"displayPossible":true,"nodeErrorMessage":null,"nodeState":"executed","nodeName":"Bar Chart (JavaScript)"}}},"version":"3.7.2.v201904170949"}